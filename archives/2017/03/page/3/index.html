<!DOCTYPE html>
<html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init">
<head>
  <meta charset="utf-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <link rel="icon" href="/favicon.ico">
  
  <title>phpsmarter</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox-1.3.4.css">
  <!--在这里倒入jquery 方便处理部分页面的jquery-->
  <script src="https://cdn.staticfile.org/jquery/1.7/jquery.min.js" type="text/javascript" ></script>
</head>
<body class="home">
	<header class="site-header navfixed-false">
  <div class="container">
      <h1><a href="/" title="phpsmarter"><span class="octicon octicon-mark-github"></span> phpsmarter</a></h1>
      <nav class="site-header-nav" role="navigation">
        
              
              <a href="/"  class=" site-header-nav-item hvr-underline-from-center" title="首页">首页</a>
        
              
              <a href="/category/" target="true" class=" site-header-nav-item hvr-underline-from-center" title="分类">分类</a>
        
              
              <a href="/open-source/"  class=" site-header-nav-item hvr-underline-from-center" title="开源项目">开源项目</a>
        
              
              <a href="/message/"  class=" site-header-nav-item hvr-underline-from-center" title="留言板">留言板</a>
        
      </nav>
  </div>
</header>

	<section class="banner-false">
    <div class="collection-head">
        <div class="container">
            <div class="collection-title">
                <h1 class="collection-header" id="site-description">
                    
                </h1>
                <div class="collection-info">
                    
                    
                        <span class="meta-info">
                            
                                <span class="octicon octicon-location">
                                   
                                        ChengDu, China
                                    
                                </span>
                                
                            
                        </span>
                    
                        <span class="meta-info">
                            
                                <span class="octicon octicon-mark-github">
                                   
                                </span>
                                
                                    <a href="http://github.com/yumemor" target="_blank">yumemor</a>
                                
                            
                        </span>
                    
                </div>
            </div>
        </div>
    </div>
</section>
	   <section class="container">
    <div class="columns">
        <div class="column two-thirds">
            
                  <article id="post-javascript开放-封闭原则-NBA常规赛结束" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2017/03/11/javascript开放-封闭原则-NBA常规赛结束/">javascript开放-封闭原则-NBA常规赛结束</a>
  

      </h3>
      <div class="repo-list-description">
        
          <blockquote>
<p>在面向对象程序(OOP)设计中，开放-封闭原则(OCP)是最重要的原则，一个oop的程序具有良好的设计，往往说明它是符合开放-封闭原则的.<br>参考《javascript模式设计与开发实践》第20章<br>首先看一个代码.开放封闭是相互关联的在一段代码中既要体现封闭又要体现开放。封闭不破坏旧功能，开放有可以添加新功能。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面这个函数是修饰模式，在函数运行后添加功能</span></div><div class="line"><span class="comment">//通过这个函数，添加的功能不影响原函数的功能</span></div><div class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params"> afterfn </span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> __self = <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">var</span> ret = __self.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">			afterfn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">			<span class="keyword">return</span> ret;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	<span class="comment">//如果多人开发，都要在window.onload下挂载函数功能(原生的js代码</span></div><div class="line">	<span class="comment">//只能加载一次window.load函数)。很有可能别人也在使用.</span></div><div class="line">	<span class="comment">//要解决这个问题可以结合after函数和函数引用赋值来解决这个问题</span></div><div class="line">	<span class="comment">//如果windoW.load已经挂载有内容，就引用赋值，然后使用after</span></div><div class="line">	<span class="comment">//如果没有使用则直接引用空函数对象，然后挂载after函数</span></div><div class="line">	<span class="comment">//无论哪种情况，通过after函数的</span></div><div class="line">	<span class="built_in">window</span>.onload = ( <span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; ).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="built_in">document</span>.getElementsByTagName( <span class="string">'*'</span> ).length );</div><div class="line">	&#125;);</div></pre></td></tr></table></figure>
<p>但是在实际应用中使用开放-封闭原则很困难，关键是要找到程序在哪里发生变化，这不是一朝一夕之功。所以道理很简单，但是应用起来可能很困难。长路漫漫啊。</p>
<p>至此本人基本把javascript的模式设计的内容过了一遍。可以说收获良多，学到很多东西。阅读代码和分析代码的能力有了提高，好像是在NBA的赛场上，通过解说员的一些战术分析，慢慢看明白了一些跑位和战术，对于一个球迷来说在这种情况下看比赛就不光光是看热闹了，比赛有了更深层次的意义，此时的心情就是有想看更多比赛来验证下一场比赛是否也会出现同样的战术。<br>但这也只是一个起点而已，过一年肯能会觉得现在写的这些文章很幼稚很傻比。就拿这些学习笔记记录这个傻逼的过程吧.</p>
<p>NBA常规赛结束了，还有季后赛和下一赛季等着呢。</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2017-03-11T08:04:10.000Z" itemprop="datePublished">2017-03-11</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Designpattern/' title=''>Designpattern</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-javascript工厂模式-XHR工厂" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2017/03/11/javascript工厂模式-XHR工厂/">javascript工厂模式-XHR工厂</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p><img src="http://upload-images.jianshu.io/upload_images/2044710-f56a2c10764090f7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/320" alt="s3398900.jpg"></p>
<blockquote>
<p>一个类或对象中往往包括别的对象。在创建这种成员对象时，你可能习惯于使用常规方式，即用new关键字和类构造函数。问题是这样会导致两个类之间产生依赖性。通过工厂模式可以消除类之间的依赖关系，他使用一个方法来决定究竟要实例化哪个类。参照上图那本书，第7章内容</p>
</blockquote>
<p>#####XHR工厂</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> AjaxHandler = <span class="keyword">new</span> Interface(<span class="string">'AjaxHandler'</span>, [<span class="string">'request'</span>, <span class="string">'createXhrObject'</span>]);</div><div class="line"></div><div class="line"><span class="comment">/* SimpleHandler class. */</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> SimpleHandler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// implements AjaxHandler</span></div><div class="line">SimpleHandler.prototype = &#123;</div><div class="line">  <span class="comment">//request函数负责执行发出的请求和处理相应结果所需的一系列操作</span></div><div class="line">  <span class="comment">//他先使用createXhrObject()函数并对其进行配置，然后发送请求</span></div><div class="line">  request: <span class="function"><span class="keyword">function</span>(<span class="params">method, url, callback, postVars</span>) </span>&#123;</div><div class="line">    <span class="comment">//首次运行或者是没有获得XHR对象时执行具体的方法。</span></div><div class="line">    <span class="comment">//一旦获取了XHR对象，就会缓存起来，后续执行直接从变量引用中获取XHR对象</span></div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">this</span>.createXhrObject();</div><div class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span>(xhr.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</div><div class="line">      (xhr.status === <span class="number">200</span>) ? </div><div class="line">        callback.success(xhr.responseText, xhr.responseXML) : </div><div class="line">        callback.failure(xhr.status);</div><div class="line">    &#125;;</div><div class="line">    xhr.open(method, url, <span class="literal">true</span>);</div><div class="line">    <span class="keyword">if</span>(method !== <span class="string">'POST'</span>) postVars = <span class="literal">null</span>;</div><div class="line">    xhr.send(postVars);</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">//createXhrObject()这个工厂方法根据当前具体环境返回一个XHR对象</span></div><div class="line">  <span class="comment">//首次执行时，他会依次尝试执行三种用于创建XHR对象的方法，一旦遇到</span></div><div class="line">  <span class="comment">//管用的，他就会返回所创建的对象，同时把自己也改为返回的那个对象</span></div><div class="line">  createXhrObject: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//工厂方法.</span></div><div class="line">    <span class="keyword">var</span> methods = [<span class="comment">//三种创建XHR对象的方法组成数组</span></div><div class="line">      <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest(); &#125;,</div><div class="line">      <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'Msxml2.XMLHTTP'</span>); &#125;,</div><div class="line">      <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>); &#125;</div><div class="line">    ];</div><div class="line">    <span class="comment">//下面遍历数组方法，尝试获得XHR对象</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = methods.length; i &lt; len; i++) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        methods[i](); <span class="comment">//尝试获得XHR对象</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span>(e) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// If we reach this point, method[i] worked.</span></div><div class="line">      <span class="comment">//如果运行到这里，数组中有方法可以创建XHR对象</span></div><div class="line">      <span class="keyword">this</span>.createXhrObject = methods[i]; <span class="comment">//直接把对象给第一种可以获取</span></div><div class="line"><span class="comment">//对象的方法，缓存起来      </span></div><div class="line">        <span class="keyword">return</span> methods[i];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// If we reach this point, none of the methods worked.</span></div><div class="line">    <span class="comment">//如果运行到这里，表示没有方法可以使用，抛出错误</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SimpleHandler: Could not create an XHR object.'</span>);</div><div class="line">  &#125; </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* Usage. 具体的使用方法*/</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> myHandler = <span class="keyword">new</span> SimpleHandler(); <span class="comment">//看不到工厂化的过程</span></div><div class="line"><span class="keyword">var</span> callback = &#123; </div><div class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">responseText</span>) </span>&#123; alert(<span class="string">'Success: '</span> + responseText); &#125;, </div><div class="line">  <span class="attr">failure</span>: <span class="function"><span class="keyword">function</span>(<span class="params">statusCode</span>) </span>&#123; alert(<span class="string">'Failure: '</span> + statusCode); &#125; </div><div class="line">&#125;;</div><div class="line">myHandler.request(<span class="string">'GET'</span>, <span class="string">'script.php'</span>, callback);</div></pre></td></tr></table></figure>
<p>createXhrObject()这个函数就是对象工厂方法，由于需要考虑到不同浏览器对于ajax对象的差异性，在获取XHR对象是有根据不同的条件来进行。但是这个<code>根据不同条件实例化XHR对象的方法</code>和实际的<code>ajax请求方法</code>是两个独立的过程。所以在这里把实例化XHR对象的过程封装到一个对象工厂里。在ajax方法中只需要使用XHR对象就可以了。 </p>
<p>两个独立的对象之间实现了解耦和。其实在js模式设计中每种模式基本都是围绕功能的解耦和来展开。要解决问题首先要简化问题，在简化过程中才能识别出模式。</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2017-03-11T00:07:10.000Z" itemprop="datePublished">2017-03-11</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Designpattern/' title=''>Designpattern</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-javascript中介者模式-咸鱼网的思考" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2017/03/11/javascript中介者模式-咸鱼网的思考/">javascript中介者模式-咸鱼网的思考</a>
  

      </h3>
      <div class="repo-list-description">
        
          <blockquote>
<p>在字典里，中介者是指“协助谈判和解决冲突的中立方”。在模式设计里，中介者是一种行为设计模式，它允许我们公开一个统一的接口，系统不同部分可以通过该接口进行通讯。<br>也许一个对象可以和十个对象之间发生联系，十个对象之间有可以发生相互联系，从而形成一张巨大的关系网，要想在这么复杂的关系网中理清关系不是一件容易的事情。<br>中介者模式就是要把对象之间的相互耦合关系解除。通过增加一个中介者对象，每个对象都和中介者对象通讯，对象之间不直接发生联系。<br>中介者对象是的对象之间的网状结构变为一对多的关系。</p>
</blockquote>
<p>拿咸鱼网来说。以前如果我们有闲置的东西，可以在小区的路上摆个摊子，这样看到东西的邻居可能会来买。可是这种关系是十分不稳定和复杂的，交易发生都有偶然性。<br>如果我们把闲置发布到咸鱼，那么发布者和购买者不会直接发生联系。之间的关系都是通过咸鱼来完成的。这样的模式就比直接交易便利的多。</p>
<p>参考《javascript设计模式与开发实践》第14章。《javascript设计模式》动物书 第9章。9.6</p>
<p>看一个简单的例子<br>这是一个捉对厮杀的游戏。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params"> name </span>)</span>&#123; <span class="comment">//玩家构造函数</span></div><div class="line">		<span class="keyword">this</span>.name = name <span class="comment">//玩家名字</span></div><div class="line">		<span class="keyword">this</span>.enemy = <span class="literal">null</span>; <span class="comment">// 敌人</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Player.prototype.win = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//获胜函数</span></div><div class="line">		<span class="built_in">console</span>.log( <span class="keyword">this</span>.name + <span class="string">' won '</span> );</div><div class="line">	&#125;;</div><div class="line">	Player.prototype.lose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//失败函数</span></div><div class="line">		<span class="built_in">console</span>.log( <span class="keyword">this</span>.name +<span class="string">' lost'</span> );</div><div class="line">	&#125;;</div><div class="line">	Player.prototype.die = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//失败函数</span></div><div class="line">		<span class="keyword">this</span>.lose();</div><div class="line">		<span class="keyword">this</span>.enemy.win();</div><div class="line">	&#125;;</div><div class="line">	<span class="comment">//接下来创建2 个玩家对象：</span></div><div class="line">	<span class="keyword">var</span> player1 = <span class="keyword">new</span> Player( <span class="string">'皮蛋'</span> );</div><div class="line">	<span class="keyword">var</span> player2 = <span class="keyword">new</span> Player( <span class="string">'小乖'</span> );</div><div class="line">	<span class="comment">//给玩家相互设置敌人：</span></div><div class="line">	player1.enemy = player2;</div><div class="line">	player2.enemy = player1;</div><div class="line"></div><div class="line">	player1.die();<span class="comment">// 输出：皮蛋 lost、小乖 won</span></div></pre></td></tr></table></figure></p>
<p>这样两个对象之间的相互作用还是比较简单的。<br>当增加玩家组队的时候，就比较复杂了，看看依照上面的思路的代码<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> players = []; <span class="comment">//玩家的数组，使用的时候是二维数组，一维是队颜色</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Player</span></span>( name, teamColor )&#123;<span class="comment">//构造函数</span></div><div class="line">		<span class="built_in">this</span>.partners = []; <span class="comment">// 队友列表</span></div><div class="line">		<span class="built_in">this</span>.enemies = []; <span class="comment">// 敌人列表</span></div><div class="line">		<span class="built_in">this</span>.state = <span class="string">'live'</span>; <span class="comment">// 玩家状态</span></div><div class="line">		<span class="built_in">this</span>.name = name; <span class="comment">// 角色名字</span></div><div class="line">		<span class="built_in">this</span>.teamColor = teamColor; <span class="comment">// 队伍颜色</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Player.prototype.win = <span class="function"><span class="keyword">function</span></span>()&#123; <span class="comment">// 玩家团队胜利</span></div><div class="line">		console.log( <span class="string">'winner: '</span> + <span class="built_in">this</span>.name );</div><div class="line">	&#125;;</div><div class="line">	Player.prototype.lose = <span class="function"><span class="keyword">function</span></span>()&#123; <span class="comment">// 玩家团队失败</span></div><div class="line">		console.log( <span class="string">'loser: '</span> + <span class="built_in">this</span>.name );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Player.prototype.die = <span class="function"><span class="keyword">function</span></span>()&#123; <span class="comment">// 玩家死亡</span></div><div class="line">		<span class="keyword">var</span> all_dead = <span class="literal">true</span>;</div><div class="line"></div><div class="line">		<span class="built_in">this</span>.state = <span class="string">'dead'</span>; <span class="comment">// 设置玩家状态为死亡，标记变量</span></div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, partner; partner = <span class="built_in">this</span>.partners[ i++ ]; )&#123; </div><div class="line">      <span class="comment">// 遍历队友列表</span></div><div class="line">			<span class="keyword">if</span> ( partner.state !== <span class="string">'dead'</span> )&#123; </div><div class="line">    <span class="comment">// 如果还有一个队友没有死亡，则游戏还未失败</span></div><div class="line">				all_dead = <span class="literal">false</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> ( all_dead === <span class="literal">true</span> )&#123; <span class="comment">// 如果队友全部死亡</span></div><div class="line">			<span class="built_in">this</span>.lose(); <span class="comment">// 通知自己游戏失败</span></div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, partner; partner = <span class="built_in">this</span>.partners[ i++ ]; )&#123;</div><div class="line"> <span class="comment">// 通知所有队友玩家游戏失败</span></div><div class="line">				partner.lose();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, enemy; enemy = <span class="built_in">this</span>.enemies[ i++ ]; )&#123;</div><div class="line"> <span class="comment">// 通知所有敌人游戏胜利</span></div><div class="line">				enemy.win();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">var</span> playerFactory = <span class="function"><span class="keyword">function</span></span>( name, teamColor )&#123;<span class="comment">//玩家对象工厂</span></div><div class="line">		<span class="keyword">var</span> <span class="keyword">new</span><span class="type">Player</span> = <span class="keyword">new</span> <span class="type">Player</span>( name, teamColor ); </div><div class="line"><span class="comment">// 创建新玩家</span></div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, player; player = players[ i++ ]; )&#123;</div><div class="line"> <span class="comment">// 通知所有的玩家，有新角色加入</span></div><div class="line">			<span class="keyword">if</span> ( player.teamColor === <span class="keyword">new</span><span class="type">Player</span>.teamColor )&#123; </div><div class="line"><span class="comment">// 如果是同一队的玩家</span></div><div class="line">				player.partners.push( <span class="keyword">new</span><span class="type">Player</span> ); </div><div class="line"><span class="comment">// 相互添加到队友列表</span></div><div class="line">				<span class="keyword">new</span><span class="type">Player</span>.partners.push( player );</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				player.enemies.push( <span class="keyword">new</span><span class="type">Player</span> ); </div><div class="line"><span class="comment">// 相互添加到敌人列表</span></div><div class="line">				<span class="keyword">new</span><span class="type">Player</span>.enemies.push( player );</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		players.push( <span class="keyword">new</span><span class="type">Player</span> );</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span><span class="type">Player</span>;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">//红队：4个玩家</span></div><div class="line">	<span class="keyword">var</span> player1 = playerFactory( <span class="string">'皮蛋'</span>, <span class="string">'red'</span> ),</div><div class="line">	player2 = playerFactory( <span class="string">'小乖'</span>, <span class="string">'red'</span> ),</div><div class="line">	player3 = playerFactory( <span class="string">'宝宝'</span>, <span class="string">'red'</span> ),</div><div class="line">	player4 = playerFactory( <span class="string">'小强'</span>, <span class="string">'red'</span> );</div><div class="line">	<span class="comment">//蓝队：4个玩家</span></div><div class="line">	<span class="keyword">var</span> player5 = playerFactory( <span class="string">'黑妞'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player6 = playerFactory( <span class="string">'葱头'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player7 = playerFactory( <span class="string">'胖墩'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player8 = playerFactory( <span class="string">'海盗'</span>, <span class="string">'blue'</span> );</div><div class="line"></div><div class="line">	player1.die();</div><div class="line">	player2.die();</div><div class="line">	player4.die();</div><div class="line">	player3.die();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上的代码就有点复杂了。当玩家失败(死亡)以后要遍历其他队友等等。加入队伍的时候也比较麻烦，要相互确认。队友之间的相互交叉变化很麻烦。</p>
</blockquote>
<p>下面看看中介者模式改造的代码。<br>重要的是添加了playerDirector这个中介者对象。<br>playerDirector中介者对象中添加接口，receiveMessage()通知中介者来进行相关操作。可以先在中介者对象中看看这个方法<br>reciveMessage( ‘playerDead’, this )；第一个参数是通知中介者的方法。第二个参数就是创建的玩家对象。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line">  <span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>中介者模式<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></div><div class="line"> function Player( name, teamColor )&#123;<span class="comment">//构造函数</span></div><div class="line">		<span class="keyword">this</span>.name = name; <span class="comment">// 角色名字</span></div><div class="line">		<span class="keyword">this</span>.teamColor = teamColor; <span class="comment">// 队伍颜色，玩家数组的第一维</span></div><div class="line">		<span class="keyword">this</span>.state = <span class="string">'alive'</span>; <span class="comment">// 玩家生存状态</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Player.prototype.win = function()&#123;<span class="comment">//胜利</span></div><div class="line">		console.log( <span class="keyword">this</span>.name + <span class="string">' won '</span> );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Player.prototype.lose = function()&#123; <span class="comment">//失败</span></div><div class="line">		console.log( <span class="keyword">this</span>.name +<span class="string">' lost'</span> );</div><div class="line">	&#125;;</div><div class="line">	<span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">****玩家死亡**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></div><div class="line">	Player.prototype.die = function()&#123;</div><div class="line">		<span class="keyword">this</span>.state = <span class="string">'dead'</span>;</div><div class="line">		playerDirector.reciveMessage( <span class="string">'playerDead'</span>, <span class="keyword">this</span> ); </div><div class="line">              <span class="comment">// 给中介者发送消息，玩家死亡</span></div><div class="line">	&#125;;</div><div class="line">	<span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">****移除玩家**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></div><div class="line">	Player.prototype.remove = function()&#123;</div><div class="line">		playerDirector.reciveMessage( <span class="string">'removePlayer'</span>, <span class="keyword">this</span> );     </div><div class="line">               <span class="comment">// 给中介者发送消息，移除一个玩家</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">****玩家换队**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></div><div class="line">	Player.prototype.changeTeam = function( color )&#123;</div><div class="line">		playerDirector.reciveMessage( <span class="string">'changeTeam'</span>, <span class="keyword">this</span>, color );     </div><div class="line">          <span class="comment">// 给中介者发送消息，玩家换队</span></div><div class="line">	&#125;;</div><div class="line">       </div><div class="line">	<span class="keyword">var</span> playerDirector= ( function()&#123; <span class="comment">//中介者构造函数</span></div><div class="line">		<span class="keyword">var</span> players = &#123;&#125;, <span class="comment">// 保存所有玩家</span></div><div class="line">			operations = &#123;&#125;; <span class="comment">// 中介者可以执行的操作</span></div><div class="line">		<span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">*新增一个玩家*</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*/</span></span></div><div class="line">		operations.addPlayer = function( player )&#123;</div><div class="line">			<span class="keyword">var</span> teamColor = player.teamColor; <span class="comment">// 玩家的队伍颜色</span></div><div class="line">			players[ teamColor ] = players[ teamColor ] || []; </div><div class="line">                   <span class="comment">// 如果该颜色的玩家还没有成立队伍，则创建</span></div><div class="line"></div><div class="line">			players[ teamColor ].push( player ); <span class="comment">// 添加玩家进队伍</span></div><div class="line">		&#125;;</div><div class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">*移除一个玩家*</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*/</span></span></div><div class="line">	operations.removePlayer = function( player )&#123;</div><div class="line">		<span class="keyword">var</span> teamColor = player.teamColor, <span class="comment">// 玩家的队伍颜色</span></div><div class="line">		teamPlayers = players[ teamColor ] || []; <span class="comment">// 该队伍所有成员</span></div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">var</span> i = teamPlayers.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- )&#123; <span class="comment">// 遍历删除</span></div><div class="line">			<span class="keyword">if</span> ( teamPlayers[ i ] === player )&#123;</div><div class="line">				teamPlayers.splice( i, <span class="number">1</span> );</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">*玩家换队*</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*/</span></span></div><div class="line">	operations.changeTeam = function( player, newTeamColor )&#123; <span class="comment">// 玩家换队</span></div><div class="line">		operations.removePlayer( player ); <span class="comment">// 从原队伍中删除</span></div><div class="line">		player.teamColor = newTeamColor; <span class="comment">// 改变队伍颜色</span></div><div class="line">		operations.addPlayer( player ); <span class="comment">// 增加到新队伍中</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	operations.playerDead = function( player )&#123; <span class="comment">// 玩家死亡</span></div><div class="line">		<span class="keyword">var</span> teamColor = player.teamColor,</div><div class="line">		teamPlayers = players[ teamColor ]; <span class="comment">// 玩家所在队伍</span></div><div class="line">		<span class="keyword">var</span> all_dead = <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, player; player = teamPlayers[ i++ ]; )&#123;</div><div class="line">			<span class="keyword">if</span> ( player.state !== <span class="string">'dead'</span> )&#123;</div><div class="line">				all_dead = <span class="keyword">false</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> ( all_dead === <span class="keyword">true</span> )&#123; <span class="comment">// 全部死亡</span></div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, player; player = teamPlayers[ i++ ]; )&#123;</div><div class="line">				player.lose(); <span class="comment">// 本队所有玩家lose</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">var</span> color <span class="keyword">in</span> players )&#123;</div><div class="line">				<span class="keyword">if</span> ( color !== teamColor )&#123;</div><div class="line">					<span class="keyword">var</span> teamPlayers = players[ color ]; </div><div class="line">                                         <span class="comment">// 其他队伍的玩家</span></div><div class="line">					<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, player; player = teamPlayers[ i++ ]; )&#123;</div><div class="line">						player.win(); <span class="comment">// 其他队伍所有玩家win</span></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">         </div><div class="line">	   <span class="keyword">var</span> reciveMessage = function()&#123;</div><div class="line">            <span class="comment">//被中介者中使用通知中介者的方法</span></div><div class="line">		<span class="keyword">var</span> message = Array.prototype.shift.call( arguments ); <span class="comment">// arguments 的第一个参数为消息名称</span></div><div class="line">		operations[ message ].apply( <span class="keyword">this</span>, arguments );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		reciveMessage: reciveMessage<span class="comment">//揭示模式的方法</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;)();</div><div class="line"></div><div class="line">	<span class="comment">// 红队：</span></div><div class="line">	<span class="keyword">var</span> player1 = playerFactory( <span class="string">'皮蛋'</span>, <span class="string">'red'</span> ),</div><div class="line">	player2 = playerFactory( <span class="string">'小乖'</span>, <span class="string">'red'</span> ),</div><div class="line">	player3 = playerFactory( <span class="string">'宝宝'</span>, <span class="string">'red'</span> ),</div><div class="line">	player4 = playerFactory( <span class="string">'小强'</span>, <span class="string">'red'</span> );</div><div class="line">	<span class="comment">// 蓝队：</span></div><div class="line">	<span class="keyword">var</span> player5 = playerFactory( <span class="string">'黑妞'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player6 = playerFactory( <span class="string">'葱头'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player7 = playerFactory( <span class="string">'胖墩'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player8 = playerFactory( <span class="string">'海盗'</span>, <span class="string">'blue'</span> );</div><div class="line">	player1.die();</div><div class="line">	player2.die();</div><div class="line">	player3.die();</div><div class="line">	player4.die();</div><div class="line"></div><div class="line">	player1.remove();</div><div class="line">	player2.remove();</div><div class="line">	player3.die();</div><div class="line">	player4.die();</div><div class="line"></div><div class="line">	player1.changeTeam( <span class="string">'blue'</span> );</div><div class="line">	player2.die();</div><div class="line">	player3.die();</div><div class="line">	player4.die();</div></pre></td></tr></table></figure></p>
<p>中介者模式中，使用者之间是不发生任何关系的。发生任何的操作都是通知中介者。中介者再通知其他使用者。<br>使用者之间的耦合解除了。</p>
<p>数组的使用上灵活度很大要注意，其他的地方还是很好理解的。</p>
<p>我感觉react组件和redux模块的相互关系就是中介者模式，您觉得呢？</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2017-03-10T21:04:10.000Z" itemprop="datePublished">2017-03-10</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Designpattern/' title=''>Designpattern</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-javascript发布-订阅者模式" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2017/03/10/javascript发布-订阅者模式/">javascript发布-订阅者模式</a>
  

      </h3>
      <div class="repo-list-description">
        
          <blockquote>
<p>这个模式看了很长时间，卡在什么地方呢？在我看来，其他的模式为了简化编程的复杂性，都是鼓励函数或者对象间<code>解耦和</code>的，但是发布-订阅者模式虽然发布者和订阅者对象分开了，但是之间的依赖关系反而更强了。 </p>
</blockquote>
<p><em>关键点</em>：1.订阅者在订阅事件的时候实际是在发布者对象的数组中写入要订阅的事件。 2.发布者在发布或者叫trigger事件的时候，实际是在发布者中遍历数组中订阅者的事件方法。<code>涉及的是消息数组的写入和遍历读出过程</code>。</p>
<p>另外一点就是，由于javascript的函数一类对象，可以直接写入数组，这样咋发布-订阅者模式中操作起来相当的方便，js真是厉害。</p>
<p>关于发布-订阅者模式和观察者模式的区别我没搞懂。这里的例子或许是观察者模式，或许是发布-订阅者模式。</p>
<blockquote>
<p>参考 《javascript设计模式》<code>pro javascript design patterns</code> 第十五章</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//发布者构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Publisher</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.subscribers = []; <span class="comment">//订阅和发布都是围绕这个数组进项</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//执行发布的方法，遍历订阅者对方法</span></div><div class="line">Publisher.prototype.deliver = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.subscribers.forEach(</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">      fn(data);</div><div class="line">    &#125;</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//订阅的方法，订阅者对象写入subscribers数组</span></div><div class="line"><span class="comment">//下面这两个方法挂载在Function原型上</span></div><div class="line"><span class="built_in">Function</span>.prototype.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">publisher</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> alreadyExists = publisher.subscribers.some(</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> ( el === that ) &#123; <span class="comment">//如果已经订阅的话，立即返回</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  );</div><div class="line">  <span class="keyword">if</span> ( !alreadyExists ) &#123; <span class="comment">//订阅者的订阅对象插入数组</span></div><div class="line">    publisher.subscribers.push(<span class="keyword">this</span>);<span class="comment">//注意命名空间</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//取消订阅的方法</span></div><div class="line"><span class="built_in">Function</span>.prototype.unsubscribe = <span class="function"><span class="keyword">function</span>(<span class="params">publisher</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">  publisher.subscribers = publisher.subscribers.filter(</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> ( el !== that ) &#123; <span class="comment">//如果是订阅对象就过滤掉</span></div><div class="line">        <span class="keyword">return</span> el;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> publisherObject = <span class="keyword">new</span> Publisher;<span class="comment">//发布者对象</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> observerObject = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;<span class="comment">//订阅者对象 </span></div><div class="line">  <span class="comment">// process data</span></div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">  <span class="comment">// unsubscribe from this publisher</span></div><div class="line">  <span class="built_in">arguments</span>.callee.unsubscribe(publisherObject);</div><div class="line">  <span class="comment">//在订阅对象中取消订阅，其实就是只执行一次发布操作</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">observerObject.subscribe(publisherObject);  </div><div class="line"><span class="comment">//执行订阅，注意这个订阅方法挂载的原型，我开始搞混了，以为代码有错</span></div></pre></td></tr></table></figure>
<blockquote>
<p>js的数组操作和高阶函数的特性使得发布-订阅者模式很好实现。<br>  这个模式我在react/redux的数据流程中觉得是有的，但是反而在模式学习中是最难的。解耦和也不是绝对的一点联系都没有，关系是<code>藕断丝连</code>，要看到断开的<code>两节藕</code>，还要看到之间的的<code>丝</code>.react/redux的学习中就要找到这层关系。</p>
</blockquote>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2017-03-10T00:04:10.000Z" itemprop="datePublished">2017-03-10</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Designpattern/' title=''>Designpattern</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-javascript适配器模式" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2017/03/10/javascript适配器模式/">javascript适配器模式</a>
  

      </h3>
      <div class="repo-list-description">
        
          <blockquote>
<p>适配器模式是为了解决软件实体间的接口不兼容性。使用适配器以后原本不兼容的两个软件的接口可以工作在一起了。<br>宗旨是不要改变原软件接口的程序代码，在外部使用适配器对数据结构做调整。<br>参考《javascript模式设计与开发实践》第17章</p>
</blockquote>
<p>第一段代码，两个地图接口之间的适配</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> googleMap = &#123;</div><div class="line">		<span class="attr">show</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)方法是<span class="title">show</span></span></div><div class="line">			<span class="title">console</span>.<span class="title">log</span>(<span class="params"> <span class="string">'开始渲染谷歌地图'</span> </span>);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="title">var</span> <span class="title">baiduMap</span> = &#123;</div><div class="line">		display: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//方法是display</span></div><div class="line">			<span class="built_in">console</span>.log( <span class="string">'开始渲染百度地图'</span> );</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> baiduMapAdapter = &#123;</div><div class="line">		<span class="attr">show</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//适配器也改为show,返回的是display</span></div><div class="line">			<span class="keyword">return</span> baiduMap.display();</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="comment">//下面是渲染地图的方法，传入地图对象</span></div><div class="line">	<span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params"> map </span>)</span>&#123;<span class="comment">//传入地图对象</span></div><div class="line">		<span class="keyword">if</span> ( map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span> )&#123; <span class="comment">//判断</span></div><div class="line">			map.show();  <span class="comment">//地图对象的show方法</span></div><div class="line">			<span class="comment">//在传入baiduMapAdapter对象的时候，调用show方法，返回的</span></div><div class="line">			<span class="comment">//实际是baiduMap的display方法。</span></div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	renderMap( googleMap ); <span class="comment">// 输出：开始渲染谷歌地图</span></div><div class="line">	renderMap( baiduMapAdapter ); <span class="comment">// 输出：开始渲染百度地图 </span></div><div class="line"> </div><div class="line"> <span class="string">``</span><span class="string">`   </span></div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">数据结构如果不同，也可以不要改动API的输出代码，只改动输出以后的数据呈现结构</div></pre></td></tr></table></figure>
<p> //其中一个API返回的数据<br> var getGuangdongCity = function(){<br>        var guangdongCity = [<br>        {<br>            name: ‘shenzhen’,<br>            id: 11,<br>        }, {<br>            name: ‘guangzhou’,<br>            id: 12,<br>        }<br>        ];<br>        return guangdongCity;<br>    };<br>    var render = function( fn ){<br>        console.log( ‘开始渲染广东省地图’ );<br>        document.write( JSON.stringify( fn() ) );<br>    };<br>    render( getGuangdongCity );</p>
<pre><code>//另一个api获得的数据
var guangdongCity = {
    shenzhen: 11,
    guangzhou: 12,
    zhuhai: 13
};

//这两个API返回的数据不同，不需要改动API的输出代码，要在输
</code></pre><p>//出以后做适配。 我们自己的API可以改动，但是如果是第三方的API就<br>//没有办法要求改动输出结构。所以最好是做适配。这个过程可能很复杂，这里只是说明有这个思路。</p>
<pre><code><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//new data</span></div><div class="line">  <span class="built_in">var</span> guangdongCity = &#123;</div><div class="line">	<span class="attribute">shenzhen</span>: <span class="number">11</span>,</div><div class="line">	<span class="attribute">guangzhou</span>: <span class="number">12</span>,</div><div class="line">	<span class="attribute">zhuhai</span>: <span class="number">13</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//按照需要把下面的输出格式改为上面代码里的格式</span></div><div class="line"><span class="comment">//old data</span></div><div class="line"><span class="built_in">var</span> getGuangdongCity = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">var</span> guangdongCity = [</div><div class="line">	&#123;</div><div class="line">		<span class="attribute">name</span>: <span class="string">'shenzhen'</span>,</div><div class="line">		<span class="attribute">id:</span><span class="string"> 11,</span></div><div class="line">	&#125;, &#123;</div><div class="line">		name: <span class="string">'guangzhou'</span>,</div><div class="line">		<span class="attribute">id:</span><span class="string"> 12,</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	];</div><div class="line">	return guangdongCity;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//新旧数据统一的渲染方法</span></div><div class="line"><span class="built_in">var</span> render = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log( <span class="string">'开始渲染广东省地图'</span> );</div><div class="line">	<span class="built_in">document</span>.write( <span class="built_in">JSON</span>.stringify( fn() ) );</div><div class="line">&#125;;</div><div class="line"> <span class="comment">//输出数据结构的适配器，把旧数据按照新数据结构的格式做适配</span></div><div class="line"><span class="built_in">var</span> addressAdapter = <span class="function"><span class="keyword">function</span>(<span class="params"> oldAddressfn </span>)</span>&#123;</div><div class="line">	<span class="built_in">var</span> address = &#123;&#125;,</div><div class="line">	oldAddress = oldAddressfn();<span class="comment">//获取就数据</span></div><div class="line">	<span class="comment">//适配的具体代码</span></div><div class="line">	<span class="keyword">for</span> ( <span class="built_in">var</span> i = <span class="number">0</span>, c; c = oldAddress[ i++ ]; )&#123;</div><div class="line">		address[ c.name ] = c.id;由数组对象改为对象存储</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> address;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//通过适配器渲染旧数据，输出的是新数据的结构</span></div><div class="line">render( addressAdapter( getGuangdongCity ) );</div></pre></td></tr></table></figure>
</code></pre><p>  就我个人来看， 适配器的思路是最简单的，但是实际操作起来可能是最复杂的，数据之间的适配可能比想象中的麻烦很多。但是了解到这个思路对于编程的灵活性有了认识，如果是以前可能遇到这样的问题的时候，首先考虑到的是怎么去修改原来的的代码。一个小思路，方法完全不同了。</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2017-03-09T17:04:10.000Z" itemprop="datePublished">2017-03-09</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Designpattern/' title=''>Designpattern</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-翻译-Redux的中间件-Reselect" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2017/03/09/翻译-Redux的中间件-Reselect/">翻译-Redux的中间件-Reselect</a>
  

      </h3>
      <div class="repo-list-description">
        
          <blockquote>
<p><strong>本文是翻译Redux的一个中间件文档.Redux是React的一个数据层,React组件的state有关逻辑处理都被单独放到Redux中来进行,在state的操作流程中衍生了很多中间件,Reselect这个中间件要解决的问题是:`在组件交互操作的时候,state发生变化的时候如何减少渲染的压力.在Reselect中间中使用了缓存机制,这个机制可以在javascript的模式设计中刚看到介绍,这里就不详细说了.</strong>仅供参考,以原文为准.</p>
<hr>
<p>一旦redux从react的数据层来理解，很多问题都似乎找到了理论依据，所谓名正言顺。在web框架中都会用数据库做数据持久层，在查表的时候会为了效率做缓存，reselect是同样的目的。React的组件有自己的特殊性，遇到特殊的特性的时候需要有特殊的处理<br>方法.</p>
</blockquote>
<p>以下是译文内容,<a href="https://github.com/reactjs/reselect" target="_blank" rel="external">原文请参见</a></p>
<hr>
<blockquote>
<p>“selector”是一个简单的Redux库,灵感来源于<code>NuclearJS</code>.</p>
<ul>
<li>Selector可以计算衍生的数据,可以让Redux做到存储尽可能少的state。</li>
<li>Selector比较高效,只有在某个参数发生变化的时候才发生计算过程.</li>
<li>Selector是可以组合的,他们可以作为输入,传递到其他的selector.</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个例子不必太在意,后面会有详细的介绍</span></div><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> shopItemsSelector = <span class="function"><span class="params">state</span> =&gt;</span> state.shop.items</div><div class="line"><span class="keyword">const</span> taxPercentSelector = <span class="function"><span class="params">state</span> =&gt;</span> state.shop.taxPercent</div><div class="line"></div><div class="line"><span class="keyword">const</span> subtotalSelector = createSelector(</div><div class="line">  shopItemsSelector,</div><div class="line">  items =&gt; items.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc + item.value, <span class="number">0</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> taxSelector = createSelector(</div><div class="line">  subtotalSelector,</div><div class="line">  taxPercentSelector,</div><div class="line">  (subtotal, taxPercent) =&gt; subtotal * (taxPercent / <span class="number">100</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> totalSelector = createSelector(</div><div class="line">  subtotalSelector,</div><div class="line">  taxSelector,</div><div class="line">  (subtotal, tax) =&gt; (&#123; <span class="attr">total</span>: subtotal + tax &#125;)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">let</span> exampleState = &#123;</div><div class="line">  <span class="attr">shop</span>: &#123;</div><div class="line">    <span class="attr">taxPercent</span>: <span class="number">8</span>,</div><div class="line">    <span class="attr">items</span>: [</div><div class="line">      &#123; <span class="attr">name</span>: <span class="string">'apple'</span>, <span class="attr">value</span>: <span class="number">1.20</span> &#125;,</div><div class="line">      &#123; <span class="attr">name</span>: <span class="string">'orange'</span>, <span class="attr">value</span>: <span class="number">0.95</span> &#125;,</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(subtotalSelector(exampleState)) <span class="comment">// 2.15</span></div><div class="line"><span class="built_in">console</span>.log(taxSelector(exampleState))      <span class="comment">// 0.172</span></div><div class="line"><span class="built_in">console</span>.log(totalSelector(exampleState))    <span class="comment">// &#123; total: 2.322 &#125;</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li><a href="#安装">Installation</a></li>
<li><a href="#实例">实例</a><ul>
<li><a href="#motivation-for-memoized-selectors">Motivation for Memoized Selectors</a></li>
<li><a href="#creating-a-memoized-selector">Creating a Memoized Selector</a></li>
<li><a href="#composing-selectors">Composing Selectors</a></li>
<li><a href="#connecting-a-selector-to-the-redux-store">Connecting a Selector to the Redux Store</a></li>
<li><a href="#accessing-react-props-in-selectors">Accessing React Props in Selectors</a></li>
<li><a href="#sharing-selectors-with-props-across-multiple-components">Sharing Selectors with Props Across Multiple Components</a></li>
</ul>
</li>
<li><a href="#api">API</a><ul>
<li><a href="#createselectorinputselectors--inputselectors-resultfunc"><code>createSelector</code></a></li>
<li><a href="#defaultmemoizefunc-equalitycheck--defaultequalitycheck"><code>defaultMemoize</code></a></li>
<li><a href="#createselectorcreatormemoize-memoizeoptions"><code>createSelectorCreator</code></a></li>
<li><a href="#createstructuredselectorinputselectors-selectorcreator--createselector"><code>createStructuredSelector</code></a></li>
</ul>
</li>
<li><p><a href="#faq">FAQ</a></p>
<ul>
<li><a href="#q-why-isnt-my-selector-recomputing-when-the-input-state-changes">Why isn’t my selector recomputing when the input state changes?</a></li>
<li><a href="#q-why-is-my-selector-recomputing-when-the-input-state-stays-the-same">Why is my selector recomputing when the input state stays the same?</a></li>
<li><a href="#q-can-i-use-reselect-without-redux">Can I use Reselect without Redux?</a></li>
<li><a href="#q-the-default-memoization-function-is-no-good-can-i-use-a-different-one">The default memoization function is no good, can I use a different one?</a></li>
<li><a href="#q-how-do-i-test-a-selector">How do I test a selector?</a></li>
<li><a href="#q-how-do-i-create-a-selector-that-takes-an-argument">How do I create a selector that takes an argument? </a></li>
<li><a href="#q-how-do-i-use-reselect-with-immutablejs">How do I use Reselect with Immutable.js?</a></li>
<li><a href="#q-can-i-share-a-selector-across-multiple-components">Can I share a selector across multiple components?</a></li>
<li><a href="#q-are-there-typescript-typings">Are there TypeScript typings?</a></li>
<li><a href="#q-how-can-i-make-a-curried-selector">How can I make a curried selector?</a></li>
</ul>
</li>
<li><p><a href="#related-projects">Related Projects</a></p>
</li>
<li><a href="#license">License</a><br>##安装<br><code>npm install reselect</code></li>
</ul>
<p>##实例</p>
<p>###缓存Selcectos的动机</p>
<blockquote>
<p>实例是基于 <a href="http://redux.js.org/docs/basics/UsageWithReact.html" target="_blank" rel="external">Redux Todos List example</a>.</p>
</blockquote>
<h4 id="containers-VisibleTodoList-js"><a href="#containers-VisibleTodoList-js" class="headerlink" title="containers/VisibleTodoList.js"></a><code>containers/VisibleTodoList.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; toggleTodo &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></div><div class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../components/TodoList'</span></div><div class="line"></div><div class="line"><span class="comment">//下面这段代码是根据过滤器的state来改变日程state的函数</span></div><div class="line"><span class="keyword">const</span> getVisibleTodos = <span class="function">(<span class="params">todos, filter</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">switch</span> (filter) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'SHOW_ALL'</span>:</div><div class="line">      <span class="keyword">return</span> todos</div><div class="line">    <span class="keyword">case</span> <span class="string">'SHOW_COMPLETED'</span>:</div><div class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> t.completed)</div><div class="line">    <span class="keyword">case</span> <span class="string">'SHOW_ACTIVE'</span>:</div><div class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> !t.completed)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">//todos是根据过滤函数返回的state，传入两个实参</span></div><div class="line">    todos: getVisibleTodos(state.todos, state.visibilityFilter)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//mapDispatchToProps来传递dispatch的方法</span></div><div class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">onTodoClick</span>: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</div><div class="line">      dispatch(toggleTodo(id))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用Redux的connect函数注入state,到TodoList组件</span></div><div class="line"><span class="keyword">const</span> VisibleTodoList = connect(</div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(TodoList)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> VisibleTodoList</div></pre></td></tr></table></figure>
<hr>
<p>在上面的例子中,<code>mapStateToProps</code>调用<code>getVisibleTodos</code>去计算<code>todos</code>.这个函数设计的是相当好的,但是有个缺点：<code>todos</code>在每一次组件更新的时候都会重新计算.如果state树的结构比较大,或者计算比较昂贵,每一次组件更新的时候都进行计算的话,将会导致性能问题.<code>Reselect</code>能够帮助redux来避免不必要的重新计算过程.</p>
<p>###创建一个缓存Selector<br>我们可以使用记忆缓存selector代替<code>getVisibleTodos</code>,如果<code>state.todos</code>和<code>state.visibilityFilter</code>发生变化,他会重新计算<code>state</code>,但是发生在其他部分的state变化,就不会重新计算.</p>
<p>Reslect提供一个函数<code>createSelector</code>来创建一个记忆selectors.<code>createSelector</code>接受一个<code>input-selectors</code>和一个变换函数作为参数.如果Redux的state发生改变造成<code>input-selector</code>的值发生改变,selector会调用变换函数,依据<code>input-selector</code>做参数,返回一个结果.如果<code>input-selector</code>返回的结果和前面的一样,那么就会直接返回有关state,会省略变换函数的调用.</p>
<p>下面我们定义一个记忆selector<code>getVisibleTodos</code>替代非记忆的版本</p>
<h4 id="selectors-index-js"><a href="#selectors-index-js" class="headerlink" title="selectors/index.js"></a><code>selectors/index.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> getVisibilityFilter = <span class="function">(<span class="params">state</span>) =&gt;</span> state.visibilityFilter</div><div class="line"><span class="keyword">const</span> getTodos = <span class="function">(<span class="params">state</span>) =&gt;</span> state.todos</div><div class="line"><span class="comment">//下面的函数是经过包装的</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> getVisibleTodos = createSelector(</div><div class="line">  [ getVisibilityFilter, getTodos ],</div><div class="line">  (visibilityFilter, todos) =&gt; &#123;</div><div class="line">    <span class="keyword">switch</span> (visibilityFilter) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'SHOW_ALL'</span>:</div><div class="line">        <span class="keyword">return</span> todos</div><div class="line">      <span class="keyword">case</span> <span class="string">'SHOW_COMPLETED'</span>:</div><div class="line">        <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> t.completed)</div><div class="line">      <span class="keyword">case</span> <span class="string">'SHOW_ACTIVE'</span>:</div><div class="line">        <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> !t.completed)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>上面的的实例中,<code>getVisibilityfilter</code>和<code>getTodos</code>是input-selectors.这两个函数是普通的非记忆selector函数,因为他们没有变换他们select的数据.<code>getVisibleTodos</code>另一方面是一个记忆selector.他接收<code>getVisibilityfilter</code>和<code>getTodos</code>作为input-selectors,并且作为一个变换函数计算筛选的todo list.</p>
<p>###聚合selectors</p>
<p>一个记忆性selector本身也可以作为另一个记忆性selector的input-selector.这里<code>getVisibleTodos</code>可以作为input-selector作为关键字筛选的input-selector:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> getKeyword = <span class="function">(<span class="params">state</span>) =&gt;</span> state.keyword</div><div class="line"></div><div class="line"><span class="keyword">const</span> getVisibleTodosFilteredByKeyword = createSelector(</div><div class="line">  [ getVisibleTodos, getKeyword ],</div><div class="line">  (visibleTodos, keyword) =&gt; visibleTodos.filter(</div><div class="line">    <span class="function"><span class="params">todo</span> =&gt;</span> todo.text.indexOf(keyword) &gt; <span class="number">-1</span></div><div class="line">  )</div><div class="line">)</div></pre></td></tr></table></figure></p>
<hr>
<p>###连接一个Selector到Redux Store<br>如果你正在使用 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">React Redux</a>, 你可以直接传递selector到 <code>mapStateToProps()</code>:</p>
<h4 id="containers-VisibleTodoList-js-1"><a href="#containers-VisibleTodoList-js-1" class="headerlink" title="containers/VisibleTodoList.js"></a><code>containers/VisibleTodoList.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; toggleTodo &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></div><div class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../components/TodoList'</span></div><div class="line"><span class="keyword">import</span> &#123; getVisibleTodos &#125; <span class="keyword">from</span> <span class="string">'../selectors'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">todos</span>: getVisibleTodos(state)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">onTodoClick</span>: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</div><div class="line">      dispatch(toggleTodo(id))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> VisibleTodoList = connect(</div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(TodoList)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> VisibleTodoList</div></pre></td></tr></table></figure>
<hr>
<p>###在React Props中接入Selectors</p>
<blockquote>
<p>这一部分我们假设程序将会有一个扩展,我们允许selector支持多todo List.请注意如果要完全实施这个扩展,reducers,components,actions等等都需要作出改变.这些内容和主题不是太相关,所以这里就省略掉了.</p>
</blockquote>
<p>目前为止,我们仅仅看到selectors接收store的state作为一个参数,其实一个selector叶可以接受props.</p>
<p>这里是一个<code>App</code>组件,渲染出三个<code>VisibleTodoList</code>组件,每一个组件有<code>ListId</code>属性.</p>
<h4 id="components-App-js"><a href="#components-App-js" class="headerlink" title="components/App.js"></a><code>components/App.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">'./Footer'</span></div><div class="line"><span class="keyword">import</span> AddTodo <span class="keyword">from</span> <span class="string">'../containers/AddTodo'</span></div><div class="line"><span class="keyword">import</span> VisibleTodoList <span class="keyword">from</span> <span class="string">'../containers/VisibleTodoList'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;VisibleTodoList listId="1" /&gt;</div><div class="line">    &lt;VisibleTodoList listId="2" /&gt;</div><div class="line">    &lt;VisibleTodoList listId="3" /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>每一个<code>VisibleTodoList</code>container应该根据各自的<code>listId</code>属性获取state的不同部分.所以我们修改一下<code>getVisibilityFilter</code>和<code>getTodos</code>,便于接受一个属性参数</p>
<h4 id="selectors-todoSelectors-js"><a href="#selectors-todoSelectors-js" class="headerlink" title="selectors/todoSelectors.js"></a><code>selectors/todoSelectors.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> getVisibilityFilter = <span class="function">(<span class="params">state, props</span>) =&gt;</span></div><div class="line">  state.todoLists[props.listId].visibilityFilter</div><div class="line"></div><div class="line"><span class="keyword">const</span> getTodos = <span class="function">(<span class="params">state, props</span>) =&gt;</span></div><div class="line">  state.todoLists[props.listId].todos <span class="comment">//这里是为二维数组了</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> getVisibleTodos = createSelector(</div><div class="line">  [ getVisibilityFilter, getTodos ],</div><div class="line">  (visibilityFilter, todos) =&gt; &#123;</div><div class="line">    <span class="keyword">switch</span> (visibilityFilter) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'SHOW_COMPLETED'</span>:</div><div class="line">        <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed)</div><div class="line">      <span class="keyword">case</span> <span class="string">'SHOW_ACTIVE'</span>:</div><div class="line">        <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> todos</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> getVisibleTodos</div></pre></td></tr></table></figure>
<hr>
<p><code>props</code>可以从<code>mapStateToProps</code>传递到<code>getVisibleTodos</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">todos</span>: getVisibleTodos(state, props)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>现在<code>getVisibleTodos</code>可以获取<code>props</code>,每一部分似乎都工作的不错.</p>
<p><em>**但是还有个问题</em><br>当<code>getVisibleTodos</code>selector和<code>VisibleTodoList</code>container的多个实例一起工作的时候,记忆功能就不能正常的运行:</p>
<h4 id="containers-VisibleTodoList-js-2"><a href="#containers-VisibleTodoList-js-2" class="headerlink" title="containers/VisibleTodoList.js"></a><code>containers/VisibleTodoList.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; toggleTodo &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></div><div class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../components/TodoList'</span></div><div class="line"><span class="keyword">import</span> &#123; getVisibleTodos &#125; <span class="keyword">from</span> <span class="string">'../selectors'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">// WARNING: THE FOLLOWING SELECTOR DOES NOT CORRECTLY MEMOIZE</span></div><div class="line">    <span class="comment">//⚠️下面的selector不能正确的记忆</span></div><div class="line">    todos: getVisibleTodos(state, props)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">onTodoClick</span>: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</div><div class="line">      dispatch(toggleTodo(id))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> VisibleTodoList = connect(</div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(TodoList)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> VisibleTodoList</div></pre></td></tr></table></figure>
<hr>
<p>使用<code>createSelector</code>创建的selector时候,如果他的参数集合和上一次的参数机会是一样的,仅仅返回缓存的值.如果我们交替渲染<code>&lt;VisibleTodoList listId=&quot;1&quot; /&gt;</code> 和<code>&lt;VisibleTodoList listId=&quot;2&quot; /&gt;</code>时,共享的selector将会交替接受<code>{listId：1}</code>和<code>{listId:2}</code>作为他的props的参数.这将会导致每一次调用的时候的参数都不同,因此selector每次都会重新来计算而不是返回缓存的值.下一部分我们将会介绍怎么解决这个问题.</p>
<p>###跨越多个组件使用selectors共性props</p>
<blockquote>
<p>这一部分的实例需要React Redux v4.3.0或者更高版本的支持.</p>
</blockquote>
<p>在多个<code>VisibleTodoList</code>组件中共享selector,同时还要<strong>保持</strong>记忆性,每一个组件的实例需要他们自己的selector备份.</p>
<p>现在让我们创建一个函数<code>makeGetVisibleTodos</code>,这个函数每次调用的时候返回一个新的<code>getVisibleTodos</code>的拷贝:</p>
<h4 id="selectors-todoSelectors-js-1"><a href="#selectors-todoSelectors-js-1" class="headerlink" title="selectors/todoSelectors.js"></a><code>selectors/todoSelectors.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> getVisibilityFilter = <span class="function">(<span class="params">state, props</span>) =&gt;</span></div><div class="line">  state.todoLists[props.listId].visibilityFilter</div><div class="line"></div><div class="line"><span class="keyword">const</span> getTodos = <span class="function">(<span class="params">state, props</span>) =&gt;</span></div><div class="line">  state.todoLists[props.listId].todos</div><div class="line"></div><div class="line"><span class="keyword">const</span> makeGetVisibleTodos = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> createSelector(</div><div class="line">    [ getVisibilityFilter, getTodos ],</div><div class="line">    (visibilityFilter, todos) =&gt; &#123;</div><div class="line">      <span class="keyword">switch</span> (visibilityFilter) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'SHOW_COMPLETED'</span>:</div><div class="line">          <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed)</div><div class="line">        <span class="keyword">case</span> <span class="string">'SHOW_ACTIVE'</span>:</div><div class="line">          <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">          <span class="keyword">return</span> todos</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> makeGetVisibleTodos</div></pre></td></tr></table></figure>
<hr>
<p>我们也需要设置给每一个组件的实例他们各自获取私有的selector方法.<code>mapStateToProps</code>的<code>connect</code>函数可以帮助完成这个功能.</p>
<p><em>**如果<code>mapStateToProps</code>提供给<code>connect</code>不返回一个对象而是一个函数,他就可以被用来为每个组件container创建一个私有的<code>mapStateProps</code>函数.</em></p>
<p>在下面的实例中,<code>mapStateProps</code>创建一个新的<code>getVisibleTodos</code>selector,他返回一个<code>mapStateToProps</code>函数,这个函数能够接入新的selector.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeMapStateToProps = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> getVisibleTodos = makeGetVisibleTodos()</div><div class="line">  <span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">todos</span>: getVisibleTodos(state, props)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> mapStateToProps</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>如果我们把<code>makeMapStateToprops</code>传递到<code>connect</code>,每一个<code>visibleTodoList</code>container将会获得各自的含有私有<code>getVisibleTodos</code>selector的<code>mapStateToProps</code>的函数.这样一来记忆就正常了,不管<code>VisibleTodoList</code>containers的渲染顺序怎么样.</p>
<h4 id="containers-VisibleTodoList-js-3"><a href="#containers-VisibleTodoList-js-3" class="headerlink" title="containers/VisibleTodoList.js"></a><code>containers/VisibleTodoList.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; toggleTodo &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></div><div class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../components/TodoList'</span></div><div class="line"><span class="keyword">import</span> &#123; makeGetVisibleTodos &#125; <span class="keyword">from</span> <span class="string">'../selectors'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> makeMapStateToProps = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> getVisibleTodos = makeGetVisibleTodos()</div><div class="line">  <span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">todos</span>: getVisibleTodos(state, props)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> mapStateToProps</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">onTodoClick</span>: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</div><div class="line">      dispatch(toggleTodo(id))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> VisibleTodoList = connect(</div><div class="line">  makeMapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(TodoList)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> VisibleTodoList</div></pre></td></tr></table></figure>
<hr>
<p>##API</p>
<p>###createSelector(…inputSelectors|[inputSelectors],resultFunc)</p>
<p>接受一个或者多个selectors,或者一个selectors数组,计算他们的值并且作为参数传递给<code>resultFunc</code>.</p>
<p><code>createSelector</code>通过判断input-selector之前调用和之后调用的返回值的全等于(===,这个地方英文文献叫reference equality,引用等于,这个单词是本质,中文没有翻译出来).经过<code>createSelector</code>创建的selector应该是immutable(不变的).</p>
<p>经过<code>createSelector</code>创建的Selectors有一个缓存,大小是1.这意味着当一个input-selector变化的时候,他们总是会重新计算state,因为Selector仅仅存储每一个input-selector前一个值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mySelector = createSelector(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.values.value1,</div><div class="line">  state =&gt; state.values.value2,</div><div class="line">  (value1, value2) =&gt; value1 + value2</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// You can also pass an array of selectors</span></div><div class="line"><span class="comment">//可以出传递一个selector数组</span></div><div class="line"><span class="keyword">const</span> totalSelector = createSelector(</div><div class="line">  [</div><div class="line">    <span class="function"><span class="params">state</span> =&gt;</span> state.values.value1,</div><div class="line">    state =&gt; state.values.value2</div><div class="line">  ],</div><div class="line">  (value1, value2) =&gt; value1 + value2</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>在selector内部获取一个组件的props非常有用.当一个selector通过<code>connect</code>函数连接到一个组件上,组件的属性作为第二个参数传递给selector:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> abSelector = <span class="function">(<span class="params">state, props</span>) =&gt;</span> state.a * props.b</div><div class="line"></div><div class="line"><span class="comment">// props only (ignoring state argument)</span></div><div class="line"><span class="keyword">const</span> cSelector =  <span class="function">(<span class="params">_, props</span>) =&gt;</span> props.c</div><div class="line"></div><div class="line"><span class="comment">// state only (props argument omitted as not required)</span></div><div class="line"><span class="keyword">const</span> dSelector = <span class="function"><span class="params">state</span> =&gt;</span> state.d</div><div class="line"></div><div class="line"><span class="keyword">const</span> totalSelector = createSelector(</div><div class="line">  abSelector,</div><div class="line">  cSelector,</div><div class="line">  dSelector,</div><div class="line">  (ab, c, d) =&gt; (&#123;</div><div class="line">    <span class="attr">total</span>: ab + c + d</div><div class="line">  &#125;)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<hr>
<p>###defaultMemoize(func, equalityCheck = defaultEqualityCheck)</p>
<p><code>defaultMemoize</code>能记住通过func传递的参数.这是<code>createSelector</code>使用的记忆函数.</p>
<p><code>defaultMemoize</code> 通过调用<code>equalityCheck</code>函数来决定一个参数是否已经发生改变.因为<code>defaultMemoize</code>设计出来就是和immutable数据一起使用,默认的<code>equalityCheck</code>使用引用全等于来判断变化:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultEqualityCheck</span>(<span class="params">currentVal, previousVal</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> currentVal === previousVal</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><code>defaultMemoize</code>和<code>createSelectorCreator</code>去<a href="#配置-equalitycheck-for-defaultmemoize">配置<code>equalityCheck</code>函数</a>.</p>
<p>###createSelectorCreator(memoize,…memoizeOptions)</p>
<p><code>createSelectorCreator</code>用来配置定制版本的<code>createSelector</code>.</p>
<p><code>memoize</code>参数是一个有记忆功能的函数,来代替<code>defaultMemoize</code>.<br><code>…memoizeOption</code>展开的参数是0或者更多的配置选项,这些参数传递给<code>memoizeFunc</code>.selectors<code>resultFunc</code>作为第一个参数传递给<code>memoize</code>,<code>memoizeOptions</code>作为第二个参数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> customSelectorCreator = createSelectorCreator(</div><div class="line">  customMemoize, <span class="comment">// function to be used to memoize resultFunc,记忆resultFunc</span></div><div class="line">  option1, <span class="comment">// option1 will be passed as second argument to customMemoize 第二个惨呼</span></div><div class="line">  option2, <span class="comment">// option2 will be passed as third argument to customMemoize 第三个参数</span></div><div class="line">  option3 <span class="comment">// option3 will be passed as fourth argument to customMemoize   第四个参数</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> customSelector = customSelectorCreator(</div><div class="line">  input1,</div><div class="line">  input2,</div><div class="line">  resultFunc <span class="comment">// resultFunc will be passed as first argument to customMemoize  作为第一个参数传递给customMomize</span></div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>在<code>customSelecotr</code>内部滴啊用memoize的函数的代码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">customMemoize(resultFunc, option1, option2, option3)</div></pre></td></tr></table></figure></p>
<hr>
<p>下面是几个可能会用到的<code>createSelectorCreator</code>的实例:</p>
<p>####为<code>defaultMemoize</code>配置<code>equalityCheck</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelectorCreator, defaultMemoize &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"><span class="keyword">import</span> isEqual <span class="keyword">from</span> <span class="string">'lodash.isEqual'</span></div><div class="line"></div><div class="line"><span class="comment">// create a "selector creator" that uses lodash.isEqual instead of ===</span></div><div class="line"><span class="keyword">const</span> createDeepEqualSelector = createSelectorCreator(</div><div class="line">  defaultMemoize,</div><div class="line">  isEqual</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// use the new "selector creator" to create a selector</span></div><div class="line"><span class="keyword">const</span> mySelector = createDeepEqualSelector(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.values.filter(<span class="function"><span class="params">val</span> =&gt;</span> val &lt; <span class="number">5</span>),</div><div class="line">  values =&gt; values.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>####使用loadsh的memoize函数来缓存未绑定的缓存.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelectorCreator &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"><span class="keyword">import</span> memoize <span class="keyword">from</span> <span class="string">'lodash.memoize'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> called = <span class="number">0</span></div><div class="line"><span class="keyword">const</span> hashFn = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.reduce(</div><div class="line">  <span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + <span class="string">'-'</span> + <span class="built_in">JSON</span>.stringify(val),</div><div class="line">  <span class="string">''</span></div><div class="line">)</div><div class="line"><span class="keyword">const</span> customSelectorCreator = createSelectorCreator(memoize, hashFn)</div><div class="line"><span class="keyword">const</span> selector = customSelectorCreator(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.a,</div><div class="line">  state =&gt; state.b,</div><div class="line">  (a, b) =&gt; &#123;</div><div class="line">    called++</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<h3 id="createStructuredSelector-inputSelectors-selectorCreator-createSelector"><a href="#createStructuredSelector-inputSelectors-selectorCreator-createSelector" class="headerlink" title="createStructuredSelector({inputSelectors}, selectorCreator = createSelector)"></a>createStructuredSelector({inputSelectors}, selectorCreator = createSelector)</h3><p>如果在普通的模式下使用<code>createStructuredSelector</code>函数可以提升便利性.传递到<code>connect</code>的selector装饰者(这是js设计模式的概念,可以参考相关的书籍)接受他的input-selectors,并且在一个对象内映射到一个键上.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mySelectorA = <span class="function"><span class="params">state</span> =&gt;</span> state.a</div><div class="line"><span class="keyword">const</span> mySelectorB = <span class="function"><span class="params">state</span> =&gt;</span> state.b</div><div class="line"></div><div class="line"><span class="comment">// The result function in the following selector</span></div><div class="line"><span class="comment">// is simply building an object from the input selectors 由selectors构建的一个对象</span></div><div class="line"><span class="keyword">const</span> structuredSelector = createSelector(</div><div class="line">   mySelectorA,</div><div class="line">   mySelectorB,</div><div class="line">   mySelectorC,</div><div class="line">   (a, b, c) =&gt; (&#123;</div><div class="line">     a,</div><div class="line">     b,</div><div class="line">     c</div><div class="line">   &#125;)</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p><code>createStructuredSelector</code>接受一个对象,这个对象的属性是input-selectors,函数返回一个结构性的selector.这个结构性的selector返回一个对象,对象的键和<code>inputSelectors</code>的参数是相同的,但是使用selectors代替了其中的值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mySelectorA = <span class="function"><span class="params">state</span> =&gt;</span> state.a</div><div class="line"><span class="keyword">const</span> mySelectorB = <span class="function"><span class="params">state</span> =&gt;</span> state.b</div><div class="line"></div><div class="line"><span class="keyword">const</span> structuredSelector = createStructuredSelector(&#123;</div><div class="line">  <span class="attr">x</span>: mySelectorA,</div><div class="line">  <span class="attr">y</span>: mySelectorB</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">const</span> result = structuredSelector(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;) <span class="comment">// will produce &#123; x: 1, y: 2 &#125;</span></div></pre></td></tr></table></figure>
<hr>
<p>结构性的selectors可以是嵌套式的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> nestedSelector = createStructuredSelector(&#123;</div><div class="line">  <span class="attr">subA</span>: createStructuredSelector(&#123;</div><div class="line">    selectorA,</div><div class="line">    selectorB</div><div class="line">  &#125;),</div><div class="line">  <span class="attr">subB</span>: createStructuredSelector(&#123;</div><div class="line">    selectorC,</div><div class="line">    selectorD</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<p>##FAQ</p>
<h3 id="Q-为什么当输入的state发生改变的时候-selector不重新计算？"><a href="#Q-为什么当输入的state发生改变的时候-selector不重新计算？" class="headerlink" title="Q:为什么当输入的state发生改变的时候,selector不重新计算？"></a>Q:为什么当输入的state发生改变的时候,selector不重新计算？</h3><p>A:检查一下你的记忆韩式是不是和你的state更新函数相兼容(例如:如果你正在使用Redux).例如:使用<code>createSelector</code>创建的selector总是创建一个新的对象,原来期待的是更新一个已经存在的对象.<code>createSelector</code>使用(===)检测输入是否改变,因此如果改变一个已经存在的对象没有触发selector重新计算的原因是改变一个对象的时候没有触发相关的检测.提示：如果你正在使用Redux,改变一个state对象的<a href="http://redux.js.org/docs/Troubleshooting.html" target="_blank" rel="external">错误可能有</a>.</p>
<p>下面的实例定义了一个selector可以决定数组的第一个todo项目是不是已经被完成:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isFirstTodoCompleteSelector = createSelector(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.todos[<span class="number">0</span>],</div><div class="line">  todo =&gt; todo &amp;&amp; todo.completed</div><div class="line">)</div></pre></td></tr></table></figure></p>
<hr>
<p>下面的state更新函数和<code>isFirstTodoCompleteSelector</code><strong>将不会</strong>正常工作工作:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">  <span class="keyword">case</span> COMPLETE_ALL:</div><div class="line">    <span class="keyword">const</span> areAllMarked = state.every(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed)</div><div class="line">    <span class="comment">// BAD: mutating an existing object</span></div><div class="line">    <span class="keyword">return</span> state.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</div><div class="line">      todo.completed = !areAllMarked</div><div class="line">      <span class="keyword">return</span> todo</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>下面的state更新函数和<code>isFirstTodoComplete</code>一起<strong>可以</strong>正常工作.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">  <span class="keyword">case</span> COMPLETE_ALL:</div><div class="line">    <span class="keyword">const</span> areAllMarked = state.every(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed)</div><div class="line">    <span class="comment">// GOOD: returning a new object each time with Object.assign</span></div><div class="line">    <span class="keyword">return</span> state.map(<span class="function"><span class="params">todo</span> =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</div><div class="line">      <span class="attr">completed</span>: !areAllMarked</div><div class="line">    &#125;))</div><div class="line"></div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>如果你没有使用Redux,但是有使用mutable数据的需求,你可以使用<code>createSelectorCreator</code>代替默认的记忆函数,并且使用不同的等值检测函数.请参看<a href="#use-memoize-function-from-lodash-for-an-unbounded-cache">这里</a> 和 <a href="#customize-equalitycheck-for-defaultmemoize">这里</a>作为参考.</p>
<p>###Q:为什么input state没有改变的时候,selector还是会重新计算?</p>
<p>A: 检查一下你的记忆函数和你你的state更新函数是不是兼容(如果是使用Redux的时候,看看reducer).例如:使用每一次更新的时候,不管值是不是发生改变,<code>createSelector</code>创建的selector总是会收到一个新的对象.<code>createSelector</code>函数使用(<code>===</code>)检测input的变化,由此可知如果每次都返回一个新对象,表示selector总是在每次更新的时候重新计算.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; REMOVE_OLD &#125; <span class="keyword">from</span> <span class="string">'../constants/ActionTypes'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> initialState = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">text</span>: <span class="string">'Use Redux'</span>,</div><div class="line">    <span class="attr">completed</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">id</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">timestamp</span>: <span class="built_in">Date</span>.now()</div><div class="line">  &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">  <span class="keyword">case</span> REMOVE_OLD:</div><div class="line">    <span class="keyword">return</span> state.filter(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> todo.timestamp + <span class="number">30</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> &gt; <span class="built_in">Date</span>.now()</div><div class="line">    &#125;)</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>下面的selector在每一次REMOVE_OLD调用的时候,都会重新计算,因为Array.filter总是返回一个新对象.但是在大多数情况下,REMOVE_OLD action都不会改变todo列表,所以重新计算是不必要的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> todosSelector = <span class="function"><span class="params">state</span> =&gt;</span> state.todos</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> visibleTodosSelector = createSelector(</div><div class="line">  todosSelector,</div><div class="line">  (todos) =&gt; &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>你可以通过state更新函数返回一个新对象来减少不必要的重计算操作,这个对象执行深度等值检测,只有深度不相同的时候才返回新对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; REMOVE_OLD &#125; <span class="keyword">from</span> <span class="string">'../constants/ActionTypes'</span></div><div class="line"><span class="keyword">import</span> isEqual <span class="keyword">from</span> <span class="string">'lodash.isEqual'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> initialState = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">text</span>: <span class="string">'Use Redux'</span>,</div><div class="line">    <span class="attr">completed</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">id</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">timestamp</span>: <span class="built_in">Date</span>.now()</div><div class="line">  &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">  <span class="keyword">case</span> REMOVE_OLD:</div><div class="line">    <span class="keyword">const</span> updatedState =  state.filter(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> todo.timestamp + <span class="number">30</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> &gt; <span class="built_in">Date</span>.now()</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> isEqual(updatedState, state) ? state : updatedState</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>替代的方法是,在selector中使用深度检测方法替代默认的<code>equalityCheck</code>函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelectorCreator, defaultMemoize &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"><span class="keyword">import</span> isEqual <span class="keyword">from</span> <span class="string">'lodash.isEqual'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> todosSelector = <span class="function"><span class="params">state</span> =&gt;</span> state.todos</div><div class="line"></div><div class="line"><span class="comment">// create a "selector creator" that uses lodash.isEqual instead of ===</span></div><div class="line"><span class="keyword">const</span> createDeepEqualSelector = createSelectorCreator(</div><div class="line">  defaultMemoize,</div><div class="line">  isEqual</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// use the new "selector creator" to create a selector</span></div><div class="line"><span class="keyword">const</span> mySelector = createDeepEqualSelector(</div><div class="line">  todosSelector,</div><div class="line">  (todos) =&gt; &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>检查<code>equalityCheck</code>函数的更替或者在state更新函数中做深度检测并不总是比重计算的花销小.如果每次重计算的花销总是比较小,可能的原因是Reselect没有通过<code>connect</code>函数传递<code>mapStateProps</code>单纯对象的原因.</p>
<h3 id="Q-没有Redux的情况下可以使用Reselect吗？"><a href="#Q-没有Redux的情况下可以使用Reselect吗？" class="headerlink" title="Q:没有Redux的情况下可以使用Reselect吗？"></a>Q:没有Redux的情况下可以使用Reselect吗？</h3><p>A:可以.Reselect没有其他任何的依赖包,因此尽管他设计的和Redux比较搭配,但是独立使用也是可以的.目前的版本在传统的Flux APP下使用是比较成功的.</p>
<blockquote>
<p>如果你使用<code>createSelector</code>创建的selectors,需要确保他的参数是immutable的.</p>
<p>看<a href="#createselectorinputselectors--inputselectors-resultfunc">这里</a></p>
</blockquote>
<h3 id="Q-怎么才能创建一个接收参数的selector"><a href="#Q-怎么才能创建一个接收参数的selector" class="headerlink" title="Q:怎么才能创建一个接收参数的selector."></a>Q:怎么才能创建一个接收参数的selector.</h3><p>A:Reselect没有支持创建接收参数的selectors,但是这里有一些实现类似函数功能的建议.</p>
<p>如果参数不是动态的,你可以使用工厂函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> expensiveItemSelectorFactory = <span class="function"><span class="params">minValue</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> createSelector(</div><div class="line">    shopItemsSelector,</div><div class="line">    items =&gt; items.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.value &gt; minValue)</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> subtotalSelector = createSelector(</div><div class="line">  expensiveItemSelectorFactory(<span class="number">200</span>),</div><div class="line">  items =&gt; items.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc + item.value, <span class="number">0</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>总的达成共识<a href="https://github.com/reactjs/reselect/issues/38" target="_blank" rel="external">看这里</a>和<a href="https://github.com/optimizely/nuclear-js/issues/14" target="_blank" rel="external">超越 neclear-js</a>是:如果一个selector需要动态的参数,那么参数应该是store中的state.如果你决定好了在应用中使用动态参数,像下面这样返回一个记忆函数是比较合适的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"><span class="keyword">import</span> memoize <span class="keyword">from</span> <span class="string">'lodash.memoize'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> expensiveSelector = createSelector(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.items,</div><div class="line">  items =&gt; memoize(</div><div class="line">    <span class="function"><span class="params">minValue</span> =&gt;</span> items.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.value &gt; minValue)</div><div class="line">  )</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> expensiveFilter = expensiveSelector(state)</div><div class="line"></div><div class="line"><span class="keyword">const</span> slightlyExpensive = expensiveFilter(<span class="number">100</span>)</div><div class="line"><span class="keyword">const</span> veryExpensive = expensiveFilter(<span class="number">1000000</span>)</div></pre></td></tr></table></figure>
<hr>
<h3 id="Q：默认的记忆函数不太好-我能用个其他的吗？"><a href="#Q：默认的记忆函数不太好-我能用个其他的吗？" class="headerlink" title="Q：默认的记忆函数不太好,我能用个其他的吗？"></a>Q：默认的记忆函数不太好,我能用个其他的吗？</h3><p>A: 我认为这个记忆韩式工作的还可以,但是如果你需要一个其他的韩式也是可以的.<br>可以看看这个<a href="#customize-equalitycheck-for-defaultmemoize">例子</a></p>
<h3 id="Q-怎么才能测试一个selector"><a href="#Q-怎么才能测试一个selector" class="headerlink" title="Q:怎么才能测试一个selector?"></a>Q:怎么才能测试一个selector?</h3><p>A:对于一个给定的input,一个selector总是产出相同的结果.基于这个原因,做单元测试是非常简单的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> selector = createSelector(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.a,</div><div class="line">  state =&gt; state.b,</div><div class="line">  (a, b) =&gt; (&#123;</div><div class="line">    <span class="attr">c</span>: a * <span class="number">2</span>,</div><div class="line">    <span class="attr">d</span>: b * <span class="number">3</span></div><div class="line">  &#125;)</div><div class="line">)</div><div class="line"></div><div class="line">test(<span class="string">"selector unit test"</span>, () =&gt; &#123;</div><div class="line">  assert.deepEqual(selector(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;), &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">6</span> &#125;)</div><div class="line">  assert.deepEqual(selector(&#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;), &#123; <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: <span class="number">9</span> &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<p>在state更新函数调用的时候同时检测selector的记忆函数的功能也是非常有用的(例如 使用Redux的时候检查reducer).每一个selector都有一个<code>recomputations</code>方法返回重新计算的次数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">suite(<span class="string">'selector'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> state = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> (</div><div class="line">    &#123;</div><div class="line">      <span class="attr">a</span>: action(state.a),</div><div class="line">      <span class="attr">b</span>: action(state.b)</div><div class="line">    &#125;</div><div class="line">  )</div><div class="line"></div><div class="line">  <span class="keyword">const</span> selector = createSelector(</div><div class="line">    <span class="function"><span class="params">state</span> =&gt;</span> state.a,</div><div class="line">    state =&gt; state.b,</div><div class="line">    (a, b) =&gt; (&#123;</div><div class="line">      <span class="attr">c</span>: a * <span class="number">2</span>,</div><div class="line">      <span class="attr">d</span>: b * <span class="number">3</span></div><div class="line">    &#125;)</div><div class="line">  )</div><div class="line"></div><div class="line">  <span class="keyword">const</span> plusOne = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span></div><div class="line">  <span class="keyword">const</span> id = <span class="function"><span class="params">x</span> =&gt;</span> x</div><div class="line"></div><div class="line">  test(<span class="string">"selector unit test"</span>, () =&gt; &#123;</div><div class="line">    state = reducer(state, plusOne)</div><div class="line">    assert.deepEqual(selector(state), &#123; <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: <span class="number">9</span> &#125;)</div><div class="line">    state = reducer(state, id)</div><div class="line">    assert.deepEqual(selector(state), &#123; <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: <span class="number">9</span> &#125;)</div><div class="line">    assert.equal(selector.recomputations(), <span class="number">1</span>)</div><div class="line">    state = reducer(state, plusOne)</div><div class="line">    assert.deepEqual(selector(state), &#123; <span class="attr">c</span>: <span class="number">6</span>, <span class="attr">d</span>: <span class="number">12</span> &#125;)</div><div class="line">    assert.equal(selector.recomputations(), <span class="number">2</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<hr>
<p>另外,selectors保留了最后一个函数调用结果的引用,这个引用作为<code>.resultFunc</code>.如果你已经聚合了其他的selectors,这个函数引用可以帮助你测试每一个selector,不需要从state中解耦测试.</p>
<p>例如如果你的selectors集合像下面这样:<br><strong>selectors.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> firstSelector = createSelector( ... )</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> secondSelector = createSelector( ... )</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> thirdSelector = createSelector( ... )</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> myComposedSelector = createSelector(</div><div class="line">  firstSelector,</div><div class="line">  secondSelector,</div><div class="line">  thirdSelector,</div><div class="line">  (first, second, third) =&gt; first * second &lt; third</div><div class="line">)</div></pre></td></tr></table></figure></p>
<hr>
<p>单元测试就像下面这样:<br><strong>test/selectors.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tests for the first three selectors...</span></div><div class="line">test(<span class="string">"firstSelector unit test"</span>, () =&gt; &#123; ... &#125;)</div><div class="line">test(<span class="string">"secondSelector unit test"</span>, () =&gt; &#123; ... &#125;)</div><div class="line">test(<span class="string">"thirdSelector unit test"</span>, () =&gt; &#123; ... &#125;)</div><div class="line"></div><div class="line"><span class="comment">// We have already tested the previous</span></div><div class="line"><span class="comment">// three selector outputs so we can just call `.resultFunc`</span></div><div class="line"><span class="comment">// with the values we want to test directly:</span></div><div class="line">test(<span class="string">"myComposedSelector unit test"</span>, () =&gt; &#123;</div><div class="line">  <span class="comment">// here instead of calling selector()</span></div><div class="line">  <span class="comment">// we just call selector.resultFunc()</span></div><div class="line">  assert(selector.resultFunc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="literal">true</span>)</div><div class="line">  assert(selector.resultFunc(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>), <span class="literal">false</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<p>最后,每一个selector有一个<code>resetRecomputations</code>方法,重置recomputations方法为0,这个参数的意图是在面对复杂的selector的时候,需要很多独立的测试,你不需要管理复杂的手工计算,或者为每一个测试创建”傻瓜”selector.</p>
<h3 id="Q-Reselect怎么和Immutble-js一起使用"><a href="#Q-Reselect怎么和Immutble-js一起使用" class="headerlink" title="Q:Reselect怎么和Immutble.js一起使用?"></a>Q:Reselect怎么和Immutble.js一起使用?</h3><p>A:<code>creatSelector</code>创建的Selectors应该可以和Immutable.js数据结构一起完美的工作.<br>如果你的selector正在重计算,并且你认为state没有发生变化,一定要确保知道哪一个Immutable.js更新方法,这个方法只要一更新<strong>总是</strong>返回新对象.哪一个方法只有<strong>集合实际发生变化的时候</strong>才返回新对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Immutable <span class="keyword">from</span> <span class="string">'immutable'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> myMap = Immutable.Map(&#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">c</span>: <span class="number">3</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"> <span class="comment">// set, merge and others only return a new obj when update changes collection</span></div><div class="line"><span class="keyword">let</span> newMap = myMap.set(<span class="string">'a'</span>, <span class="number">1</span>)</div><div class="line">assert.equal(myMap, newMap)</div><div class="line">newMap = myMap.merge(&#123; <span class="string">'a'</span>, <span class="number">1</span> &#125;)</div><div class="line">assert.equal(myMap, newMap)</div><div class="line"><span class="comment">// map, reduce, filter and others always return a new obj</span></div><div class="line">newMap = myMap.map(<span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">1</span>)</div><div class="line">assert.notEqual(myMap, newMap)</div></pre></td></tr></table></figure>
<hr>
<p>如果一个操作导致的selector更新总是返回一个新对象,可能会发生不必要的重计算.<a href="#q-why-is-my-selector-recomputing-when-the-input-state-stays-the-same">看这里</a>.这是一个关于pros的讨论,使用深全等于来检测例如<code>immutable.js</code>来减少不必要的重计算过程.</p>
<h3 id="Q-可以在多个组件之间共享selector吗？"><a href="#Q-可以在多个组件之间共享selector吗？" class="headerlink" title="Q:可以在多个组件之间共享selector吗？"></a>Q:可以在多个组件之间共享selector吗？</h3><p>A: 使用<code>createSelector</code>创建的Selector的缓存的大小只有1.这个设定使得多个组件的实例之间的参数不同,跨组件共享selector变得不合适.这里也有几种办法来解决这个问题:</p>
<ul>
<li>使用工程函数方法,为每一个组件实例创建一个新的selector.这里有一个内建的工厂方法,React Redux v4.3或者更高版本可以使用. <a href="#sharing-selectors-with-props-across-multiple-components">看这里</a></li>
<li>创建一个缓存尺寸大于1的定制selector.</li>
</ul>
<h3 id="Q-有TypeScript的类型吗？"><a href="#Q-有TypeScript的类型吗？" class="headerlink" title="Q:有TypeScript的类型吗？"></a>Q:有TypeScript的类型吗？</h3><p>A: 是的！他们包含在<code>package.json</code>里.可以很好的工作.</p>
<h3 id="Q：怎么构建一个柯里化selector"><a href="#Q：怎么构建一个柯里化selector" class="headerlink" title="Q：怎么构建一个柯里化selector?"></a>Q：怎么构建一个<a href="https://github.com/hemanth/functional-programming-jargon#currying" target="_blank" rel="external">柯里化</a>selector?</h3><p>A：尝试一些这里<a href="https://github.com/reactjs/reselect/issues/159#issuecomment-238724788" target="_blank" rel="external">助手函数</a>,由<a href="https://github.com/MattSPalmer" target="_blank" rel="external">MattSPalmer</a>提供</p>
<h2 id="有关的项目"><a href="#有关的项目" class="headerlink" title="有关的项目"></a>有关的项目</h2><h3 id="reselect-map"><a href="#reselect-map" class="headerlink" title="reselect-map"></a><a href="https://github.com/HeyImAlex/reselect-map" target="_blank" rel="external">reselect-map</a></h3><p>因为Reselect不可能保证缓存你所有的需求,在做<strong>非常昂贵的计算</strong>的时候,这个方法比较有用.查看一下reselect-maps readme</p>
<p><strong>reselect-map的优化措施仅仅使用在一些小的案例中,如果你不确定是不是需要他,就不要使用它</strong>.</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2017-03-09T00:04:10.000Z" itemprop="datePublished">2017-03-09</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/翻译/' title=''>翻译</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-javascript设计原则-单一职责" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2017/03/09/javascript设计原则-单一职责/">javascript设计原则-单一职责</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>前面把javascript的设计模式基本过了一遍，可以说是感慨很多，许多的思想都是从未接触过的，学起来难度也不小，但是我觉得这个过程是很值得的。如果以前是在足球场上踢野球的话，现在总算找到一个像模像样的教练在指导了，不一定会成为一个世界级的球星，但是水平至少也会比以前提高很多。<br>接下来会看看一些设计原则，设计原则是比模式更高一级的方法，是纲领性的内容。</p>
<blockquote>
<p>单一职责(single responsable princple)被定为为“引起变化的原因”。如果一个方法承担了过多的职责，那么在需求发生变化的过程中，需要改写这个方法的可能性就越大。<br>因此SRP原则体现为：一个对象(方法)只做一件事情。<br>参考《javascript设计模式与开发实践》第18章</p>
</blockquote>
<p>#####设计模式中的SRP原则</p>
<p>代理模式<br>下面这个例子是要在文档中创建一个img标签，并且要插入图片<br>在加载图片的时候，由于网速的限制需要预先加载一张本地图片，稍后会加载网络图片。 在这个过程中<code>创建img标签</code>和<code>更换图片源</code>是<code>没有关系</code>的。所以最好是把这两个过程分为两个对象来处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建img标签的对象</span></div><div class="line"><span class="keyword">var</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement( <span class="string">'img'</span> );</div><div class="line">		<span class="built_in">document</span>.body.appendChild( imgNode );</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			<span class="attr">setSrc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;</div><div class="line"></div><div class="line">				imgNode.src = src;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;)();</div><div class="line">  <span class="comment">//添加图片路径的对象</span></div><div class="line">	<span class="keyword">var</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> img = <span class="keyword">new</span> Image; <span class="comment">//实例化标签对象</span></div><div class="line">		img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			myImage.setSrc( <span class="keyword">this</span>.src ); <span class="comment">//加载默认图片</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			<span class="attr">setSrc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;</div><div class="line">				myImage.setSrc( <span class="string">'file:// /C:/Users/svenzeng/Desktop/loading.gif'</span> );</div><div class="line">				img.src = src;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;)();</div><div class="line">	<span class="comment">//更改图片的路径，这个过程就和img标签的创建对象没有关系了。</span></div><div class="line">	proxyImage.setSrc( <span class="string">'http:// imgcache.qq.com/music/photo/000GGDys0yA0Nk.jpg'</span> );</div></pre></td></tr></table></figure></p>
<p>迭代器模式<br>看下面段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这段代码往文档中添加div元素，但是有限制，这里就只能添加数组</span></div><div class="line"><span class="comment">//有两个职责一个是添加元素，一个是遍历数据，所有有必要分开</span></div><div class="line"> <span class="keyword">var</span> appendDiv=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;l=data.length;i&lt;l;i++)&#123;</div><div class="line">   <span class="keyword">var</span> div=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">   div.innerHTML=data[i];</div><div class="line">   <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">  &#125;</div><div class="line"> &#125;;</div><div class="line"> </div><div class="line"> appenDiv([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div></pre></td></tr></table></figure></p>
<p>使用单一职责原则改变代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> each = <span class="function"><span class="keyword">function</span>(<span class="params"> obj, callback </span>) </span>&#123;<span class="comment">//遍历的方法</span></div><div class="line"><span class="comment">//对象和数组都可以输入，灵活性加大，并且还可以修改</span></div><div class="line">		<span class="keyword">var</span> value,</div><div class="line">		i = <span class="number">0</span>,</div><div class="line">		length = obj.length,</div><div class="line">		isArray = isArraylike( obj ); <span class="comment">// isArraylike 函数未实现，可以翻阅jQuery 源代码</span></div><div class="line">		<span class="keyword">if</span> ( isArray ) &#123; <span class="comment">// 迭代类数组</span></div><div class="line">			<span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</div><div class="line">				callback.call( obj[ i ], i, obj[ i ] );</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">for</span> ( i <span class="keyword">in</span> obj ) &#123; <span class="comment">// 迭代object 对象</span></div><div class="line">				value = callback.call( obj[ i ], i, obj[ i ] );</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> obj;</div><div class="line">	&#125;;</div><div class="line"> <span class="comment">//根据输入数据的元素添加方法</span></div><div class="line">	<span class="keyword">var</span> appendDiv = <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123;</div><div class="line">		each( data, <span class="function"><span class="keyword">function</span>(<span class="params"> i, n </span>)</span>&#123; <span class="comment">//使用each方法来执行遍历</span></div><div class="line">		<span class="comment">//在回调函数中根据遍历数据添加元素至文档中</span></div><div class="line">			<span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</div><div class="line">			div.innerHTML = n;</div><div class="line">			<span class="built_in">document</span>.body.appendChild( div );</div><div class="line">		&#125;);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	appendDiv( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ] );<span class="comment">//数组数据</span></div><div class="line">	appendDiv(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>,<span class="attr">d</span>:<span class="number">4</span>&#125; ); <span class="comment">//对象数据</span></div></pre></td></tr></table></figure></p>
<p>单例模式</p>
<p>在前面已经有笔记了。实际是把实际操作和创建单例的方法分别封装在两个方法里。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> createLoginLayer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//创建元素的方法</span></div><div class="line">		<span class="keyword">var</span> div;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">if</span> ( !div )&#123;</div><div class="line">				div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</div><div class="line">				div.innerHTML = <span class="string">'我是登录浮窗'</span>;</div><div class="line">				div.style.display = <span class="string">'none'</span>;</div><div class="line">				<span class="built_in">document</span>.body.appendChild( div );</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> div; <span class="comment">//单例的判断依据</span></div><div class="line">		&#125;</div><div class="line">	&#125;)();</div><div class="line">  </div><div class="line">        <span class="comment">//创建和检测单例的方法，参数为创建元素的方法</span></div><div class="line">	<span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123; <span class="comment">// 获取单例</span></div><div class="line">		<span class="keyword">var</span> result;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> result || ( result = fn .apply(<span class="keyword">this</span>, <span class="built_in">arguments</span> ) ); </div><div class="line">                        <span class="comment">//这个地方要注意apply和arguments的应用</span></div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 创建登录浮窗</span></div><div class="line">		<span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</div><div class="line">		div.innerHTML = <span class="string">'我是登录浮窗'</span>;</div><div class="line">		<span class="built_in">document</span>.body.appendChild( div );</div><div class="line">		<span class="keyword">return</span> div;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	<span class="keyword">var</span> createSingleLoginLayer = getSingle( createLoginLayer );</div><div class="line">	<span class="keyword">var</span> loginLayer1 = createSingleLoginLayer();</div><div class="line">	<span class="keyword">var</span> loginLayer2 = createSingleLoginLayer();</div><div class="line">	alert ( loginLayer1 === loginLayer2 ); <span class="comment">// 输出： true  //为同一对象</span></div></pre></td></tr></table></figure></p>
<p>装饰者模式<br>前面的设计模式里也有介绍<br>装饰者模式可以动态为对象添加方法或指责。从而也使的对象的功能单一化。<br>下面两个函数调用的时候指向同一个对象。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params"> afterfn </span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> __self = <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">var</span> ret = __self.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">			 <span class="comment">//执行原函数</span></div><div class="line">			afterfn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );<span class="comment">//执行after函数</span></div><div class="line">			<span class="keyword">return</span> ret;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="string">'打开登录浮层'</span> );</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="string">'上报标签为: '</span> + <span class="keyword">this</span>.getAttribute( <span class="string">'tag'</span> ) );</div><div class="line"></div><div class="line">	&#125;;</div><div class="line">	<span class="built_in">document</span>.getElementById( <span class="string">'button'</span> ).onclick = showLogin.after( log );</div><div class="line"><span class="comment">// 打开登录浮层之后上报数据</span></div></pre></td></tr></table></figure></p>
<p>#####单一职责原则减低了单个类或者对象的复杂度，按照指责把对象分解成更小的粒度。有助于代码的复用，修改和测试。但是代码复杂度是提高了。怎么平衡呢？这是个问题。</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2017-03-08T20:04:10.000Z" itemprop="datePublished">2017-03-08</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Designpattern/' title=''>Designpattern</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-javascript最少知识原则" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2017/03/09/javascript最少知识原则/">javascript最少知识原则</a>
  

      </h3>
      <div class="repo-list-description">
        
          <blockquote>
<p>最少知识原则说的是一个软件实体应当尽可能的与其他实体减少相互作用。<br>这里的软件实体是一个广义概念，不仅包括对象，还包括系统，类，模块，函数，变量灯。这样来说最少知识原则涵盖的范围就很大了。下面看看和javascript相关的内容<br>参考《javascirpt模式设计与开发实践》第19章</p>
</blockquote>
<ol>
<li><p>减少对象之间的联系<br>最少知识原则指导我们，如果两个对象之间不必彼此通讯，那么这两个对象之间就不要发生直接联系。常见的做法是引入一个第三者来承担彼此的通信任务。</p>
</li>
<li><p>javascript设计模式中的最少知识原则</p>
</li>
</ol>
<p><strong>中介者模式</strong><br>这个模式是使用者们是不发生任何联系的，所有的信息都是由中介者来完成。<br>react通过引入redux应该就是这种模式。react组件之间不再发生任何的联系，所有与组件state变化的通讯请求都是通过redux来完成的。这样一来，组件可以应对复杂的state变化。</p>
<p><strong>外观模式</strong><br>这是针对使用者而言的。外观模式作用是对交互使用者隐藏子系统的复杂性。</p>
<ul>
<li>[ ] 外观模式为一组系统提供一个便利的入口。在jquery中兼容了浏览器的差异，但是使用者使用的是同一个api接口，就是一个体现</li>
<li>[ ] 隔离使用者和复杂系统的联系，使用者不需要去了解具体的差异</li>
</ul>
<p>javascript的函数封装</p>
<p>javascript函数有着至高无上的权利，灵活性很大。通过使用闭包隐藏变量，通过单例模式，揭示模式，策略模式.javascript使用函数和对象字面量的方法隐藏具体的实现逻辑。只暴露相关的方法。</p>
<p>这就是最少知识原则。这也是基础原则在javascript程序设计中应该是时刻都要体现这种原则。</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2017-03-08T19:04:10.000Z" itemprop="datePublished">2017-03-08</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Designpattern/' title=''>Designpattern</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-javascript设计模式-单例模式" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2017/03/08/javascript设计模式-单例模式/">javascript设计模式-单例模式</a>
  

      </h3>
      <div class="repo-list-description">
        
          <blockquote>
<p>单例模式的定义：保证一个类仅有一个实例，并提供一个访问他的全局访问点<br>参考书籍《javascript设计模式与开发实践》<br>有一些对象我们只需要一个，例如线程池，全局缓存等。</p>
</blockquote>
<ol>
<li>实例单例模式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.instance = <span class="literal">null</span>;</div><div class="line">	&#125;;</div><div class="line">	Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert ( <span class="keyword">this</span>.name );</div><div class="line">	&#125;;</div><div class="line">	Singleton.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span> ( !<span class="keyword">this</span>.instance )&#123;  <span class="comment">//对实例进行检测</span></div><div class="line">			<span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton( name ); <span class="comment">//全局缓存new 对象</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.instance;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> a = Singleton.getInstance( <span class="string">'sven1'</span> );  <span class="comment">//第一次实例化，检测没有实例化的对象，自己实例化一个，然后缓存</span></div><div class="line">	<span class="keyword">var</span> b = Singleton.getInstance( <span class="string">'sven2'</span> );<span class="comment">//第二次实例化，检测已经有全局的实例化的对象，直接返回，不进行具体实例化</span></div><div class="line">	alert ( a === b ); <span class="comment">// true    //统一实例对象</span></div></pre></td></tr></table></figure>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2017-03-08T11:04:10.000Z" itemprop="datePublished">2017-03-08</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Designpattern/' title=''>Designpattern</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-javascript中的this关键字" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/2017/03/08/javascript中的this关键字/">javascript中的this关键字</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>前面对这个问题总是雾里看花，像🌧像雾又像风。最近综合着看了一些书和文章才算是基本搞清楚了。<br>主要参考《javascrpt设计模式与开发指南》</p>
<p>javascript(缩写js)语言中的this和java,php中的this是完全不同的概念。<br>js中的this是动态的，总是指向一个对象，但是这个对象是谁，需要根据函数的调用上下文来决定。</p>
<ol>
<li>作为对象的方法调用(显示绑定)</li>
<li>作为普通的函数来调用(默认绑定)</li>
<li>作为构造器来调用</li>
<li>call和apply方法调用</li>
</ol>
<p>1作为对象的方法调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">		<span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">		<span class="attr">getA</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			alert ( <span class="keyword">this</span> === obj ); <span class="comment">// 输出：true</span></div><div class="line">			alert ( <span class="keyword">this</span>.a ); <span class="comment">// 输出: 1</span></div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	obj.getA();  <span class="comment">//函数被绑定在对象obj上，this指向obj对象</span></div><div class="line">	<span class="comment">//这种方法，可以立即看到绑定的对象是那一个，所以是最简单的</span></div></pre></td></tr></table></figure></p>
<p>2作为普通函数的调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在浏览器的JavaScript 里，这个全局对象是window 对象。</span></div><div class="line">	<span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//这个函数没有指定对象，默认绑定在window对象上</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;;</div><div class="line">	<span class="built_in">console</span>.log( getName() ); <span class="comment">// 输出：globalName</span></div><div class="line"></div><div class="line">	<span class="comment">//或者：</span></div><div class="line">	<span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> myObject = &#123;</div><div class="line">		<span class="attr">name</span>: <span class="string">'sven'</span>,</div><div class="line">		<span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">  <span class="comment">//下面这个引用是比较迷惑人的，在用变量引用一个对象的方法时候，变量仅仅指向函数本身，和原来函数定义在哪个对象里没有任何关系，这一点要注意</span></div><div class="line">	<span class="keyword">var</span> getName = myObject.getName; <span class="comment">//getName函数任然是默认绑定在window全局对象上</span></div><div class="line">	<span class="built_in">console</span>.log( getName() ); <span class="comment">// globalName</span></div></pre></td></tr></table></figure></p>
<p><code>下面这个实例，我个人认为是js this中最为迷惑的地方，需要注意，可能学了很长时间都对这个地方迷惑，没有什么原因，js就是这么规定的。</code></p>
<p><code>那，到底规定什么了？就是 函数内部的函数，也就是闭包函数的对象是默认绑定在全局，全局，全局 对象上的，一定，一定，一定 要记住这一点</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>我是一个div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"></div><div class="line">	<span class="built_in">window</span>.id = <span class="string">'window'</span>;</div><div class="line"></div><div class="line">	<span class="built_in">document</span>.getElementById( <span class="string">'div1'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert ( <span class="keyword">this</span>.id ); <span class="comment">// 输出：'div1'</span></div><div class="line">		<span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//这个函数内部的函数，他是默认绑定在window上的</span></div><div class="line">			alert ( <span class="keyword">this</span>.id ); <span class="comment">// 输出：'window' </span></div><div class="line">		&#125;</div><div class="line">		callback();</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">  <span class="comment">//那么要是内部函数要使用外部函数绑定的对象怎么办。</span></div><div class="line">  <span class="comment">//好办，就是把外部函数的对象保存在一个变量中</span></div><div class="line">  <span class="comment">//经常在代码中看到的 var that=this就是这个作用</span></div><div class="line">  <span class="comment">//在内部函数要使用同一个对象就可以用that了。或者用 var  self=this </span></div><div class="line">  <span class="comment">//这仅仅是变量的名字不同，道理都一样</span></div><div class="line">	<span class="built_in">document</span>.getElementById( <span class="string">'div1'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 保存div 的引用</span></div><div class="line">		<span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			alert ( that.id ); <span class="comment">// 输出：'div1'  //that指向了外部函数的对象</span></div><div class="line">		&#125;</div><div class="line">		callback();</div><div class="line">	&#125;;</div></pre></td></tr></table></figure>
<p>在 ECMA es5的严格模式下<br>问题又有改变了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">use strict </div><div class="line"></div><div class="line">这时候，内部函数的<span class="keyword">this</span>不在默认指向<span class="built_in">window</span>对象，而是指向undefine，实际就是没有默认绑定对象。</div></pre></td></tr></table></figure>
<p>3构造器调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = <span class="string">'sven'</span>;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();  <span class="comment">//当使用构造器调用的时候，构造器返回一个对象，this就指向这个对象</span></div><div class="line">	alert ( obj.name ); <span class="comment">// 输出：sven</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = <span class="string">'sven'</span>;</div><div class="line">		<span class="keyword">return</span> &#123; <span class="comment">// 显式地返回一个对象</span></div><div class="line">			name: <span class="string">'anne'</span></div><div class="line">		&#125;</div><div class="line">	&#125;;</div></pre></td></tr></table></figure></p>
<p>4call apply 调用<br>硬式绑定，通过传参方式动态改变函数的绑定对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> obj1 = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">'sven'</span>,</div><div class="line">	<span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">'anne'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( obj1.getName() ); <span class="comment">// 输出: sven</span></div><div class="line"><span class="comment">//下面这个函数硬式绑定到obj2对象上</span></div><div class="line"><span class="built_in">console</span>.log( obj1.getName.call( obj2 ) ); <span class="comment">// 输出：anne</span></div></pre></td></tr></table></figure>
<p>这就是this。</p>
<p>关键字的内容，关键的地方是对概念有一定吃透，出问题都是概念不清楚引起的</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2017-03-08T00:04:10.000Z" itemprop="datePublished">2017-03-08</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/javascript/' title=''>javascript</a>
          </span>
        
      
        <!--
          
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
          
        -->

      </p>
    </div>
  </article>
            
        </div>
        <div class="column one-third">
          <!--处理未安装 search 插件 默认 Google 搜索-->
 

<h3>Search</h3>

<div id="site_search">

	<!-- Google -->
	

	<!-- 本地搜索 -->
	
		<form id="search-form" >
			<input type="text" id="search" placeholder="Search" >
			<button type="button" class="btn btn-default" id="site_search_do"><span class="octicon octicon-search"></span></button>
		</form>

		<div id="local-search-result"></div>

		<script src="/js/search.js"></script>	
		<script type="text/javascript">
			$(function(){
				var currentIndex = -1;
				var search_path = "search.xml";
				if (!search_path) search_path = "search.xml";
				var path = "/" + search_path;
				searchFunc(path, 'search', 'local-search-result');

				$(document).delegate("#local-search-result>.search-result-list li","hover",function(){
					var liNode = $("#local-search-result>.search-result-list li");
					liNode.removeClass("hover");
					currentIndex = $("#local-search-result>.search-result-list li").index($(this));
					liNode.eq(currentIndex).addClass("hover");
				})

				$("#search-form").submit(function(){
					return false;
				})

				$("#search").keydown(function(event){
					var keyCode = event.keyCode;
					var liNode = $("#local-search-result>.search-result-list li");
					if(keyCode == 38 || keyCode == 40 || keyCode == 13){
						liNode.removeClass("hover");
						if(keyCode == 38){
							if(currentIndex - 1 >= 0) currentIndex --;
						}
						if(keyCode == 40){
							if(currentIndex + 1 < liNode.length) currentIndex ++;
						}
						if(keyCode == 13){
							location.href = liNode.eq(currentIndex).find("a").attr("href");
						}
						liNode.eq(currentIndex).addClass("hover");
						return false;
					}else{
						currentIndex = -1;
					}
				})
			})
		</script>

	

</div>

<h3>Popular Repositories</h3>
    <div class="popular-container"></div>
    
    <script type="text/template" id="popular-list-template">
        <a href="{%=clone_url%}" class="card text-center" target="_blank">
            <div class="thumbnail">
                <div class="card-image geopattern" data-pattern-id="{%=name%}">
                    <div class="card-image-cell">
                        <h3 class="card-title">
                            {%=name%}
                        </h3>
                    </div>
                </div>
                <div class="caption">
                    <div class="card-description">
                        <p class="card-text">
                            {%=description%}
                        </p>
                    </div>
                    <div class="card-text">
                        <span class="meta-info tooltipped tooltipped-n" aria-label="{%=stargazers_count%} stars">
                            <span class="octicon octicon-star"></span> {%=stargazers_count%}
                        </span>
                        <span class="meta-info tooltipped tooltipped-n" aria-label="{%=forks_count%} forks">
                            <span class="octicon octicon-git-branch"></span> {%=forks_count%}
                        </span>
                        <span class="meta-info tooltipped tooltipped-n" aria-label="最后更新时间：{%=updated_at%}">
                            <span class="octicon octicon-clock"></span>
                            <time datetime="{%=updated_at%}">{%=updated_at%}</time>
                        </span>
                    </div>
                </div>
            </div>
        </a>
    </script>

    <script src="/js/baiduTemplate.js"></script>
    <script type="text/javascript">
        var popular_repos = function(){

            var baiduTpl = new Object();

            var handleTpl = function(){
                baiduTpl.popular_list = baidu.template("popular-list-template");
            };

            var handleGithub = function(){
                var popularContainer = $(".popular-container");

                var repos = "hexo-theme-primer".split(",");
                for(var i in repos){
                    var name = repos[i];
                    $.get("https://api.github.com/repos/yumemor/"+name,handle);
                }

                function handle(result){
                    result.updated_at = result.updated_at.split("T")[0];
                    if(result){
                        var html = baiduTpl.popular_list(result);
                        popularContainer.append(html);
                        $(".geopattern").each(function(){           
                            $(this).geopattern($(this).data('pattern-id'));
                        });
                    }
                }
            };

            return {
                init:function(){
                    handleTpl();
                    handleGithub();
                }
            }
        }; 
        $(popular_repos().init);
    </script>

        </div>
    </div>

    
      <div class="pagination text-align">
          <div class="btn-group">
              <a class="extend prev" rel="prev" href="/archives/2017/03/page/2/">&laquo;</a><a class="page-number" href="/archives/2017/03/">1</a><a class="page-number" href="/archives/2017/03/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/archives/2017/03/page/4/">4</a><a class="page-number" href="/archives/2017/03/page/5/">5</a><a class="page-number" href="/archives/2017/03/page/6/">6</a><a class="extend next" rel="next" href="/archives/2017/03/page/4/">&raquo;</a>
          </div>
      </div>
    
</section>

<footer class="container">
    <div class="site-footer" role="contentinfo">
        <div class="copyright left mobile-block">
                © 2016
                <span title="yumemor">yumemor</span>
                <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a>
        </div>

        <ul class="site-footer-links right mobile-hidden">
            <li>
                <a href="javascript:window.scrollTo(0,0)" >TOP</a>
            </li>
        </ul>

        <a href="https://github.com/yumemor/hexo-theme-primer" target="_blank" aria-label="view source code">
            <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
        </a>

        <ul class="site-footer-links mobile-hidden">
            
                  
                  <li>
                    <a href="/"  title="首页">首页</a>
                  </li>
            
                  
                  <li>
                    <a href="/category/" target="true" title="分类">分类</a>
                  </li>
            
                  
                  <li>
                    <a href="/open-source/"  title="开源项目">开源项目</a>
                  </li>
            
                  
                  <li>
                    <a href="/message/"  title="留言板">留言板</a>
                  </li>
            
            <li>
                <a href="/atom.xml">
                    <span class="octicon octicon-rss" style="color:orange;"></span>
                </a>
            </li>
        </ul>
    </div>
</footer>

		<script src="/js/geopattern.js"></script>
		<script src="/js/highlight.pack.js"></script>
		<script src="/lib/fancybox/jquery.fancybox-1.3.4.pack.js"></script>

		

		<script src="/js/index.js"></script>

		 <script src="/js/popular_repo.js"></script> 

	</body>
</html>