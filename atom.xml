<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>phpsmarter</title>
  <subtitle>A beginner of React-native</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-23T11:33:16.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>phpsmarter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试文件</title>
    <link href="http://yoursite.com/2017/03/23/new-article-2/"/>
    <id>http://yoursite.com/2017/03/23/new-article-2/</id>
    <published>2017-03-23T15:31:30.000Z</published>
    <updated>2017-03-23T11:33:16.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>翻译-如何使用React,Redux和Immutable-js构建Todo-App</title>
    <link href="http://yoursite.com/2017/03/23/%E7%BF%BB%E8%AF%91-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8React,Redux%E5%92%8CImmutable-js%E6%9E%84%E5%BB%BATodo-App/"/>
    <id>http://yoursite.com/2017/03/23/翻译-如何使用React,Redux和Immutable-js构建Todo-App/</id>
    <published>2017-03-23T00:04:10.000Z</published>
    <updated>2017-03-23T11:29:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文是翻译版本,<a href="https://www.sitepoint.com/how-to-build-a-todo-app-using-react-redux-and-immutable-js/" target="_blank" rel="external">原文请见</a><br><em>By Dan Prince  May 03, 2016</em></p>
</blockquote>
<p>React使用组件和单向数据流方式描述用户界面,但是React对state的处理非常的简单.这一点让我们知道,React仅仅只当于传统的<code>Model-View-Controller</code>构架的<code>View</code>层.</p>
<p>仅仅使用React也可以构建大型的app,但是很快我们会发现,要保持代码的简洁,我们需要在其他地方管理state(把state的管理独立出来).</p>
<p>没有官方管理应用state的工具,但是有几个库工作的的不错.今天我们添加两个库和React一起来构建一个简单的app.</p>
<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux是一个小型的js库,作为app的state容器.糅合了Fluc和Elm的概念.我们可以使用Redux管理任何app的state,只要我们紧扣下面的指导：</p>
<ol>
<li>我们的state保持在一个单一的store中</li>
<li>state的改变只会来自于actions</li>
</ol>
<p>Redux的核心 store是一个函数,它接收当前的application的state和一个action,合并创建一个新的application state,这个函数叫做Reducer.</p>
<p>我们的React组件负责发送actions到我们的store,反过来,如果组件需要渲染的时候,store会通知他.</p>
<h2 id="ImmutableJS"><a href="#ImmutableJS" class="headerlink" title="ImmutableJS"></a>ImmutableJS</h2><p>因为Redux不允许我们mutate程序的state,如果借助immutable数据结构模型化应用程序的state将会非常的有用.<br><code>Immutable.js</code>使用突变界面(mutative interfaces)提供一些immutable数据结构,这些界面实施时非常的高效,灵感来自于Clojure和Scala.</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>我们将会使用React,Redux和ImmutableJS去构建一个简单的todo list,允许我们添加todos,在完成和未完成之间切换.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">//css</div><div class="line"> html, body, input, button &#123;</div><div class="line">  font-family: Sawasdee;</div><div class="line">  font-size: 20px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.todo &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.todo__list &#123;</div><div class="line">  margin: 0;</div><div class="line">  padding: 0;</div><div class="line">  list-style-type: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.todo__item &#123;</div><div class="line">  padding: .5em .25em;</div><div class="line">  border-bottom: solid 1px #eee;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.todo__item:hover &#123;</div><div class="line">  background: #f7f7f7;</div><div class="line">  cursor: pointer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.todo__entry &#123;</div><div class="line">  border: solid 1px #ccc;</div><div class="line">  padding: .25em .5em;</div><div class="line">  border-radius: .2em;</div><div class="line">  background: #f3f3f3;</div><div class="line">  width: 100%;</div><div class="line">  box-sizing: border-box;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.todo__button &#123;</div><div class="line">  border: 0;</div><div class="line">  border-radius: .2em;</div><div class="line">  background: #71B7FF;  </div><div class="line">  color: #fff;</div><div class="line">  padding: .25em .5em;</div><div class="line">  margin: .5em 0;</div><div class="line">  margin-right: .25em;</div><div class="line">  cursor: pointer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.todo__button:hover &#123;</div><div class="line">  background: #B2D8FF;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//js</span></div><div class="line"><span class="keyword">const</span> &#123; <span class="built_in">Map</span>, List &#125; = Immutable;</div><div class="line"><span class="keyword">const</span> &#123; createStore &#125; = Redux;</div><div class="line"><span class="keyword">const</span> &#123; Provider, connect &#125; = reactRedux;</div><div class="line"></div><div class="line"><span class="keyword">const</span> components = &#123;</div><div class="line">  Todo(&#123; todo &#125;) &#123;</div><div class="line">    <span class="keyword">if</span>(todo.isDone) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">strike</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">strike</span>&gt;</span></span>;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  TodoList(&#123; todos, toggleTodo, addTodo &#125;) &#123;</div><div class="line">    <span class="keyword">const</span> onSubmit = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">const</span> text = e.target.value;</div><div class="line">      <span class="keyword">if</span>(e.which === <span class="number">13</span> &amp;&amp; text.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        addTodo(text);</div><div class="line">        e.target.value = <span class="string">''</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> toggleClick = <span class="function">(<span class="params">id</span>) =&gt;</span> () =&gt; toggleTodo(id);</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> &#123; Todo &#125; = components;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className='todo'&gt;</div><div class="line">        &lt;input type='text'</div><div class="line">               className='todo__entry'</div><div class="line">               placeholder='Add todo'</div><div class="line">               onKeyDown=&#123;onSubmit&#125; /&gt;</div><div class="line">        &lt;ul className='todo__list'&gt;</div><div class="line">          &#123;todos.map(t =&gt; (</div><div class="line">            &lt;li</div><div class="line">              key=&#123;t.get('id')&#125;</div><div class="line">              className='todo__item'</div><div class="line">              onClick=&#123;toggleClick(t.get('id'))&#125;&gt;</div><div class="line">              &lt;Todo todo=&#123;t.toJS()&#125; /&gt;</div><div class="line">            &lt;/li&gt;</div><div class="line">          ))&#125; </div><div class="line">        &lt;/ul&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const actions = &#123;</div><div class="line">  addTodo(text) &#123;</div><div class="line">    return &#123;</div><div class="line">      type: 'ADD_TODO',</div><div class="line">      payload: &#123;</div><div class="line">        id: Math.random().toString(34).slice(2),</div><div class="line">        isDone: false,</div><div class="line">        text</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line">  toggleTodo(id) &#123;</div><div class="line">    return &#123;</div><div class="line">      type: 'TOGGLE_TODO',</div><div class="line">      payload: id</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const init = List();</div><div class="line"></div><div class="line">const reducer = function(state=init, action) &#123;</div><div class="line">  switch(action.type) &#123;</div><div class="line">    case 'ADD_TODO':</div><div class="line">      return state.push(</div><div class="line">        Map(action.payload)</div><div class="line">      );</div><div class="line">    case 'TOGGLE_TODO':</div><div class="line">      return state.map(t =&gt; &#123;</div><div class="line">        if(t.get('id') == action.payload) &#123;</div><div class="line">          return t.update('isDone', isDone =&gt; !isDone);</div><div class="line">        &#125; else &#123;</div><div class="line">          return t;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    default:</div><div class="line">      return state;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const containers = &#123;</div><div class="line">  TodoList: connect(</div><div class="line">    function mapStateToProps(state) &#123;</div><div class="line">      return &#123;</div><div class="line">        todos: state</div><div class="line">      &#125;;</div><div class="line">    &#125;,</div><div class="line">    function mapDispatchToProps(dispatch) &#123;</div><div class="line">      return &#123;</div><div class="line">        toggleTodo: (id) =&gt; dispatch(actions.toggleTodo(id)),</div><div class="line">        addTodo: (text) =&gt; dispatch(actions.addTodo(text))</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">  )(components.TodoList)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const &#123; TodoList &#125; = containers;</div><div class="line">const store = createStore(reducer);</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">    &lt;TodoList /&gt;</div><div class="line">  &lt;/Provider&gt;,</div><div class="line">  document.getElementById('app')</div><div class="line">);</div></pre></td></tr></table></figure>
<hr>
<p>代码在 <a href="https://github.com/sitepoint-editors/immutable-redux-todo" target="_blank" rel="external">Github</a></p>
<blockquote>
<p>可能提示build失败,<code>npm install babel-core</code>试试</p>
</blockquote>
<h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>从创建项目📂开始,建立一个package.json文件.然后安装需要的依赖包.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> npm install --save react react-dom redux react-redux immutable</div><div class="line">npm install --save-dev webpack babel-loader babel-preset-es2015 babel-preset-react</div></pre></td></tr></table></figure>
<hr>
<p>使用JSX和ES2015,用Babel编译代码,使用Webpack来完成这个模块绑定过程.</p>
<p>在<code>webpack.config.js</code>文件中创建Webpack配置文件.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./src/app.js'</span>,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: __dirname,</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">loaders</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">'babel'</span>,</div><div class="line">        <span class="attr">query</span>: &#123; <span class="attr">presets</span>: [ <span class="string">'es2015'</span>, <span class="string">'react'</span> ] &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<p>最后扩展一下<code>package.json</code>,添加一个npm script使用source maps编译我们的代码.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> "scripts": &#123;</div><div class="line">  "build": "webpack --debug"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>每次编译代码的时候,运行<code>npm run build</code>.</p>
<h2 id="React-amp-Components"><a href="#React-amp-Components" class="headerlink" title="React&amp;Components"></a>React&amp;Components</h2><p>在实施项目之前,先创建一些傻瓜数据有很大的用处,但我们构思需要渲染的组件的时候,有一点点初步的感觉.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">const</span> dummyTodos = [</div><div class="line">  &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">isDone</span>: <span class="literal">true</span>,  <span class="attr">text</span>: <span class="string">'make components'</span> &#125;,</div><div class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">isDone</span>: <span class="literal">false</span>, <span class="attr">text</span>: <span class="string">'design actions'</span> &#125;,</div><div class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">isDone</span>: <span class="literal">false</span>, <span class="attr">text</span>: <span class="string">'implement reducer'</span> &#125;,</div><div class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">isDone</span>: <span class="literal">false</span>, <span class="attr">text</span>: <span class="string">'connect components'</span> &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<hr>
<p>我们需要两个React组件<code>&lt;Todo/&gt;</code>和<code>&lt;TodoList&gt;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// src/components.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Todo</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; todo &#125; = props;</div><div class="line">  <span class="keyword">if</span>(todo.isDone) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">strike</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">strike</span>&gt;</span></span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; todos &#125; = props;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div className='todo'&gt;</div><div class="line">      &lt;input type='text' placeholder='Add todo' /&gt;</div><div class="line">      &lt;ul className='todo__list'&gt;</div><div class="line">        &#123;todos.map(t =&gt; (</div><div class="line">          &lt;li key=&#123;t.id&#125; className='todo__item'&gt;</div><div class="line">            &lt;Todo todo=&#123;t&#125; /&gt;</div><div class="line">          &lt;/li&gt;</div><div class="line">        ))&#125;</div><div class="line">      &lt;/ul&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>到了这一步,可以创建<code>index.html</code>文件来测试这些组价,添加下面的标记</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Immutable Todo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<hr>
<p>还有一个项目的入口文件<code>src/app.js</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/app.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> &#123; TodoList &#125; <span class="keyword">from</span> <span class="string">'./components'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> dummyTodos = [</div><div class="line">  &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">isDone</span>: <span class="literal">true</span>,  <span class="attr">text</span>: <span class="string">'make components'</span> &#125;,</div><div class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">isDone</span>: <span class="literal">false</span>, <span class="attr">text</span>: <span class="string">'design actions'</span> &#125;,</div><div class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">isDone</span>: <span class="literal">false</span>, <span class="attr">text</span>: <span class="string">'implement reducer'</span> &#125;,</div><div class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">isDone</span>: <span class="literal">false</span>, <span class="attr">text</span>: <span class="string">'connect components'</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line">render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">TodoList</span> <span class="attr">todos</span>=<span class="string">&#123;dummyTodos&#125;</span> /&gt;</span>,</span></div><div class="line">  document.getElementById('app')</div><div class="line">);</div></pre></td></tr></table></figure>
<hr>
<p>使用<code>npm run build</code>编译文件,然后在浏览器中打开index.html文件,确保运行.</p>
<h2 id="Redux-amp-ImmutableJS"><a href="#Redux-amp-ImmutableJS" class="headerlink" title="Redux&amp;ImmutableJS"></a>Redux&amp;ImmutableJS</h2><p>现在我们有了很好的UI,可以开始考虑组件最后的state.开始创建的傻瓜数据是一个很好的开端,我们可以很容易转化为ImmutableJS集合.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">import</span> &#123; List, <span class="built_in">Map</span> &#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> dummyTodos = List([</div><div class="line">  <span class="built_in">Map</span>(&#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">isDone</span>: <span class="literal">true</span>,  <span class="attr">text</span>: <span class="string">'make components'</span> &#125;),</div><div class="line">  <span class="built_in">Map</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">isDone</span>: <span class="literal">false</span>, <span class="attr">text</span>: <span class="string">'design actions'</span> &#125;),</div><div class="line">  <span class="built_in">Map</span>(&#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">isDone</span>: <span class="literal">false</span>, <span class="attr">text</span>: <span class="string">'implement reducer'</span> &#125;),</div><div class="line">  <span class="built_in">Map</span>(&#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">isDone</span>: <span class="literal">false</span>, <span class="attr">text</span>: <span class="string">'connect components'</span> &#125;)</div><div class="line">]);</div></pre></td></tr></table></figure>
<hr>
<p>ImmutableJS map和Javascript的对象工作方式不同,所以我们要对组件做一点轻微的改变.property接入的地方(例如：todo.id)需要使用一个方法调用来代替(例如:<code>todo.get(‘id’)</code>).</p>
<h2 id="设计Actions"><a href="#设计Actions" class="headerlink" title="设计Actions"></a>设计Actions</h2><p>现在我们获得了数据的特征,可以考虑一下actions的更新.这个实例中,我们仅仅需要两个acions,一个是添加新的todo,另一个转换todo的状态.</p>
<p>让我们定义几个函数创建这些actions</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">// src/actions.js</span></div><div class="line"></div><div class="line"><span class="comment">// succinct hack for generating passable unique ids</span></div><div class="line"><span class="keyword">const</span> uid = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random().toString(<span class="number">34</span>).slice(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'ADD_TODO'</span>,</div><div class="line">    <span class="attr">payload</span>: &#123;</div><div class="line">      <span class="attr">id</span>: uid(),</div><div class="line">      <span class="attr">isDone</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">text</span>: text</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toggleTodo</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'TOGGLE_TODO'</span>,</div><div class="line">    <span class="attr">payload</span>: id</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>每一个action仅仅是一个有type和payload的属性对象.在我们触发action后,type属性帮助我们用payload来作什么.</p>
<h2 id="设计一个Reducer"><a href="#设计一个Reducer" class="headerlink" title="设计一个Reducer"></a>设计一个Reducer</h2><p>现在我们知道了state的特性和更新state的action,我们可以创建reducer了.仅仅提醒一下,reducer是一个接收state和action的函数,然后用来计算更新state.</p>
<p>这里是我们reducer的初始结构.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// src/reducer.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; List, <span class="built_in">Map</span> &#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> init = List([]);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">todos=init, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    <span class="keyword">case</span> <span class="string">'TOGGLE_TODO'</span>:</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> todos;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>操作<code>ADD_TODO</code>action非常简单,可是使用<code>.push()</code>方法,返回一个新的列表,添加todo到末尾.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</div><div class="line"> <span class="keyword">return</span> todos.push(<span class="built_in">Map</span>(action.payload));</div></pre></td></tr></table></figure>
<hr>
<p>记住要push到列表之前,要把todo对象转变为immutable map.</p>
<p>我们需要处理的稍微复杂的action是<code>TOOGLE_TODO</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'TOGGLE_TODO'</span>:</div><div class="line"> <span class="keyword">return</span> todos.map(<span class="function"><span class="params">t</span> =&gt;</span> &#123;</div><div class="line">   <span class="keyword">if</span>(t.get(<span class="string">'id'</span>) === action.payload) &#123;</div><div class="line">     <span class="keyword">return</span> t.update(<span class="string">'isDone'</span>, isDone =&gt; !isDone);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="keyword">return</span> t;</div><div class="line">   &#125;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<hr>
<p>我们使用<code>.map()</code>遍历列表,找到与aciton<code>id</code>匹配的todo项目.之后我们调用<code>.update()</code>方法,接收一个键和函数,然后返回一个map的新拷贝到updata函数,新拷贝中新值替换了初始值.</p>
<p>字面量版本<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">const</span> todo = <span class="built_in">Map</span>(&#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">'foo'</span>, <span class="attr">isDone</span>: <span class="literal">false</span> &#125;);</div><div class="line">todo.update(<span class="string">'isDone'</span>, isDone =&gt; !isDone);</div><div class="line"><span class="comment">// =&gt; &#123; id: 0, text: 'foo', isDone: true &#125;</span></div></pre></td></tr></table></figure></p>
<hr>
<h2 id="把所有的东西都连系到一起"><a href="#把所有的东西都连系到一起" class="headerlink" title="把所有的东西都连系到一起"></a>把所有的东西都连系到一起</h2><p>actions和reducer准备好了,可以创建一个store,连接到我们的React组件中.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// src/app.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> &#123; TodoList &#125; <span class="keyword">from</span> <span class="string">'./components'</span>;</div><div class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = createStore(reducer);</div><div class="line"></div><div class="line">render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">TodoList</span> <span class="attr">todos</span>=<span class="string">&#123;store.getState()&#125;</span> /&gt;</span>,</span></div><div class="line">  document.getElementById('app')</div><div class="line">);</div></pre></td></tr></table></figure>
<hr>
<p>为了保持组件和store的独立,我们使用<code>react-redux</code>帮助简化这个过程.它允许我们创建独立于store的容器,包装所有的组件,我们不需要改变先前的设计.</p>
<p>我们需要一个容器包装<code>&lt;TodoList/&gt;</code>组件,看看下面的内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// src/containers.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> components <span class="keyword">from</span> <span class="string">'./components'</span>;</div><div class="line"><span class="keyword">import</span> &#123; addTodo, toggleTodo &#125; <span class="keyword">from</span> <span class="string">'./actions'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> TodoList = connect(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">)(components.TodoList);</div></pre></td></tr></table></figure>
<hr>
<p>我们使用<code>connect</code>函数创建容器.当我们调用<code>connect()</code>函数,传递两个函数,<code>mapStateToProps()</code>和<code>mapDispatchToProps()</code>.</p>
<p><code>mapStateToProps()</code>函数接收当前store的state作为参数,期待返回一个我们包装组件需要的对象映射.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">todos</span>: state &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>下面代码是一个包装组件根据映射map可视化的结果.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;TodoList todos=&#123;state&#125; /&gt;</div></pre></td></tr></table></figure>
<hr>
<p>我们也需要提供<code>mapDispatchProps</code>函数,传递store的<code>dispatch</code>方法,所以我们可以使用action creatros来dispatch actions.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">addTodo</span>: <span class="function"><span class="params">text</span> =&gt;</span> dispatch(addTodo(text)),</div><div class="line">    <span class="attr">toggleTodo</span>: <span class="function"><span class="params">id</span> =&gt;</span> dispatch(toggleTodo(id))</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>再一次实例化组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;TodoList todos=&#123;state&#125;</div><div class="line">         addTodo=&#123;text =&gt; dispatch(addTodo(text))&#125;</div><div class="line">         toggleTodo=&#123;id =&gt; dispatch(toggleTodo(id))&#125; /&gt;</div></pre></td></tr></table></figure>
<hr>
<p>现在我们已经把action creators映射到组件,可以从事件监听中调用.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; todos, toggleTodo, addTodo &#125; = props;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> onSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> input = event.target;</div><div class="line">    <span class="keyword">const</span> text = input.value;</div><div class="line">    <span class="keyword">const</span> isEnterKey = (event.which == <span class="number">13</span>);</div><div class="line">    <span class="keyword">const</span> isLongEnough = text.length &gt; <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(isEnterKey &amp;&amp; isLongEnough) &#123;</div><div class="line">      input.value = <span class="string">''</span>;</div><div class="line">      addTodo(text);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> toggleClick = <span class="function"><span class="params">id</span> =&gt;</span> event =&gt; toggleTodo(id);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div className='todo'&gt;</div><div class="line">      &lt;input type='text'</div><div class="line">             className='todo__entry'</div><div class="line">             placeholder='Add todo'</div><div class="line">             onKeyDown=&#123;onSubmit&#125; /&gt;</div><div class="line">      &lt;ul className='todo__list'&gt;</div><div class="line">        &#123;todos.map(t =&gt; (</div><div class="line">          &lt;li key=&#123;t.get('id')&#125;</div><div class="line">              className='todo__item'</div><div class="line">              onClick=&#123;toggleClick(t.get('id'))&#125;&gt;</div><div class="line">            &lt;Todo todo=&#123;t.toJS()&#125; /&gt;</div><div class="line">          &lt;/li&gt;</div><div class="line">        ))&#125;</div><div class="line">      &lt;/ul&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>container容器自动订阅store的变化,只要的映射的props变化的时候,容器包装的组件就会重新渲染.</p>
<p>最后,需要使容器组件独立于store,使用<code>&lt;Provider/&gt;</code>组件.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// src/app.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span>;</div><div class="line"><span class="keyword">import</span> &#123; TodoList &#125; <span class="keyword">from</span> <span class="string">'./containers'</span>;</div><div class="line"><span class="comment">//                          ^^^^^^^^^^</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> store = createStore(reducer);</div><div class="line"></div><div class="line">render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">TodoList</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<hr>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>不可否认,对于初学者来说,React和Redux的生态系统是相当复杂和令人迷惑的.<br>但是好消息是这些概念是可以可以转移的.我们仅仅粗略的接触了Redux的基础构架,但是已经足够我们学习<code>Elm 构架</code>,或者选取ClojureScript库例如：<code>Om</code>,<code>Re-frame</code>.类似的,我们仅仅看到immutable数据结构的只言片语,但是已经足够我们学习<code>Clojure</code>或者<code>Haskell</code>.</p>
<p>不管你是刚开始探索有关state的web编程开发者,还是使用javascript很长时间的开发者,基于action构架的办成和immutable数据结构变得至观重要的技能.所以现在是学习这些内容的时间了.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是翻译版本,&lt;a href=&quot;https://www.sitepoint.com/how-to-build-a-todo-app-using-react-redux-and-immutable-js/&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>翻译-让我们把React-Container组合起来</title>
    <link href="http://yoursite.com/2017/03/21/%E7%BF%BB%E8%AF%91-%E8%AE%A9%E6%88%91%E4%BB%AC%E6%8A%8AReact-Container%E7%BB%84%E5%90%88%E8%B5%B7%E6%9D%A5/"/>
    <id>http://yoursite.com/2017/03/21/翻译-让我们把React-Container组合起来/</id>
    <published>2017-03-21T00:04:10.000Z</published>
    <updated>2017-03-23T11:29:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>Arunoda Susiripala</em>  <a href="https://voice.kadira.io/let-s-compose-some-react-containers-3b91b6d9b7c8#.92sjwgug1" target="_blank" rel="external">请参看原文</a></p>
</blockquote>
<p>近来(Jan,2016),自给自足的container(Redux的容器)方法在React的社区中非常的流行.他们在Realy,Redux甚至是在Meteor中广泛使用.这篇文章里我们深入container内部,了解一下怎么简便的组合containers.</p>
<h2 id="什么是Container"><a href="#什么是Container" class="headerlink" title="什么是Container?"></a>什么是Container?</h2><p>在React中,我们有props和states来管理组件的数据需求.最近有一个趋势,在组件中仅仅只通过props来接收数据和action.我们仅仅在组件内部保留state.</p>
<p>我们有时候叫这些组件为“单纯展示组件”.<br>我也不太确定谁发明的这个术语.但是我才可能是<a href="https://medium.com/@dan_abramov" target="_blank" rel="external">Dan Abramov</a>.<br>查看一下他的文章“Smart and Dumb Components”.</p>
<p>但是我认为叫做<strong><code>UI组件</code></strong>更好一点(或者仅仅叫做组件).<br>接着又另一套组件实际管理本地数据和获取远程数据.这些组件被称为<strong><code>container组件</code></strong>.Relay和Redux的React绑定是他们更流行了.</p>
<p>下面是怎么使用Reat Devtools来查看组件的视图.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2044710-f461d4894bfc06de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="1*QhMLf9dhu-cbAxN9Gc9dtg-2.png"></p>
<p>Container(BlogPost)接收postId Props.然后他将会获取数据传递到实际UI组件中.</p>
<h2 id="Container的常规任务"><a href="#Container的常规任务" class="headerlink" title="Container的常规任务"></a>Container的常规任务</h2><p>container的主要任务是获取数据,这里面有一些事情要做,让我们看看:</p>
<ul>
<li>请求数据(调用订阅或者仅仅获取数据)</li>
<li>当数据加载的时候展示加载图片</li>
<li>一旦数据返回,把它传递到UI组件中</li>
<li>如果有错误,展示给用户</li>
<li>当props改变了,需要重新获取或者重新订阅</li>
<li>当container卸载的时候,需要清除资源.</li>
</ul>
<p>这里container有很多的任务要完成.如果你想自己做这些任务,你就不得不做一些重复的工作,发生错误的来源就由此诞生了.</p>
<h2 id="React-Komposer的介绍"><a href="#React-Komposer的介绍" class="headerlink" title="React Komposer的介绍"></a>React Komposer的介绍</h2><p>React Komposer试图帮助我们更容易的合并containers.有了它,你可以使用任何数据资源,不管你的数据是来自于Promise,Observable甚至是Meteor‘s Tracker.</p>
<h3 id="让我们看看一个简单的例子"><a href="#让我们看看一个简单的例子" class="headerlink" title="让我们看看一个简单的例子"></a>让我们看看一个简单的例子</h3><p>像下面这样创建一个<em>数字时钟</em>:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2044710-10d84673aea28707.gif?imageMogr2/auto-orient/strip" alt="Digital clock"></p>
<p>这是一个好的实例,因为我们可以测试一个container的几乎所有的功能.开始</p>
<p>首先安装react-komposer:</p>
<p><code>npm i — save react-komposer</code></p>
<p>然后输入compose函数：<br><code>import {compose} from ‘react-komposer’;</code></p>
<p>现在需要一个UI组件去渲染时间:</p>
<p><code>const Time = ({time}) =&gt; (&lt;div&gt;{time}&lt;/div&gt;);</code></p>
<p>这是我们的组合函数:</p>
<p>获取时间的时候需要调用<code>onData</code>回调函数(这里没有实际做什么.)</p>
<p>需要调用<code>onData</code>函数多少次可以,只要程序需要.如果有错误,可以把错误信息作为<code>onData</code>的第一个值.</p>
<p>最后,我们需要返回一个清除资源的额函数.在这个实例中用他来清除setInterva的句柄.</p>
<p>好了,现在来合并一下composer:<br><code>const Clock = compose(composerFunction)(Time);</code></p>
<p>然后渲染到DOM中:<br><code>ReactDOM.render(&lt;Clock /&gt;, document.body);</code></p>
<p>现在我们得到了一个自我管理(state)的时钟.<a href="https://jsfiddle.net/arunoda/jxse2yw8/" target="_blank" rel="external">看看实际演示</a>.</p>
<p>这里有个<a href="https://jsfiddle.net/arunoda/7qy1mxc7/" target="_blank" rel="external">更复杂的版本</a>,使用props,处理错误信息.</p>
<p>你也可以改变默认加载和错误组件.查看一下<a href="https://github.com/kadirahq/react-komposer#api" target="_blank" rel="external">react-komposer 文档</a>.</p>
<p>获得好处:更容易测试</p>
<p>作为这个组件的附加效果,我们现在可以很容易测试UI代码.</p>
<ul>
<li>因为UI组件仅仅通过props接收数据(和action),是的测试很容易.</li>
<li>也可以测试组合函数的数据获取逻辑.</li>
</ul>
<h2 id="对于多种数据源的支持"><a href="#对于多种数据源的支持" class="headerlink" title="对于多种数据源的支持"></a>对于多种数据源的支持</h2><p>我已经提到过,可以使用这个组件和任何数据源一起工作,因为组合的API是通用的.我们有处理流行数据源的特定APIS.<br> 这里是:</p>
<ul>
<li><em>composeWithPromise</em>用于Promise-baseed 数据源</li>
<li><em>composeWithObservable</em>用于Rx.js Observalbe-based数据源</li>
<li><em>composeWithTracker</em>出事特殊的一些数据源.</li>
</ul>
<p>有了这些API,我们可以使用react-komposer去合并任何数据源的container.</p>
<p>看看<a href="https://github.com/kadirahq/react-komposer#using-with-xxx" target="_blank" rel="external">repo</a>,有更多的例子.</p>
<p>在你的app中使用一下react-komposer,你会喜欢上他的.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Arunoda Susiripala&lt;/em&gt;  &lt;a href=&quot;https://voice.kadira.io/let-s-compose-some-react-containers-3b91b6d9b7c8#.92sjwgug1&quot; t
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript动态类型，鸭子终于煮熟了</title>
    <link href="http://yoursite.com/2017/03/20/javascript%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%B8%AD%E5%AD%90%E7%BB%88%E4%BA%8E%E7%85%AE%E7%86%9F%E4%BA%86/"/>
    <id>http://yoursite.com/2017/03/20/javascript动态类型，鸭子终于煮熟了/</id>
    <published>2017-03-20T00:04:10.000Z</published>
    <updated>2017-03-23T12:06:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>冬至来了，刚去吃了一碗萝卜饺子，浑身发热。突然觉得鸭子已经熟了。</p>
<p>开个玩笑。这里要说的是动态语言的鸭子类型(ducking type)。 <code>这个话题应该是整个javascript面向对象编程的核心思想</code>.不知道下这个结论对不对？可是在前面还不太了解到底是什么意思。看代码的时候总有种感觉，就是javascript太灵活了，怎么什么对象的方法都可以直接通过参数传递的方式来在另一个函数中使用。在模式学习时常看到这种代码。<br>刚才又重新看这部分内容时突然明白了。这个方法就是面向对象编程里的鸭子模型。</p>
<p>什么是鸭子类型呢？我总结一句话，英雄不问出处，只要能干活就行。javascript里面对象都是蓝领，只干活，至于是小学水平还是博士水平，我们不关心，能干活就行。 java语言就不是，java在你干活之前想要把你的祖宗十八代都查一遍，根正苗红的才能来干活。所以javascript就很灵活啦。</p>
<p>这就是鸭子类型。<code>如果它走起路来像鸭子，叫起来嘎嘎的，那么它就是鸭子</code>。</p>
<p>鸭子类型赋予了javascript极大的灵活性，动态调用对象方法的时候非常自由。 </p>
<p>参考《javascript模式设计与开发实践》 第一章</p>
<p>看下面代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> duck = &#123;  <span class="comment">//鸭子对象</span></div><div class="line">		duckSinging: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log( <span class="string">'嘎嘎嘎'</span> );</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> chicken = &#123;  <span class="comment">//鸡对象</span></div><div class="line">		duckSinging: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log( <span class="string">'嘎嘎嘎'</span> );</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> choir = []; <span class="comment">// 合唱团</span></div><div class="line">	<span class="keyword">var</span> joinChoir = <span class="function"><span class="keyword">function</span>(<span class="params"> animal </span>)</span>&#123; <span class="comment">//实例化动物对象</span></div><div class="line">		<span class="keyword">if</span> ( animal &amp;&amp; <span class="keyword">typeof</span> animal.duckSinging === <span class="string">'function'</span> )&#123; </div><div class="line">       <span class="comment">//稍作检测，只要有唱歌的方法就可以用。</span></div><div class="line">			choir.push( animal );</div><div class="line">			<span class="built_in">console</span>.log( <span class="string">'恭喜加入合唱团'</span> );</div><div class="line">			<span class="built_in">console</span>.log( <span class="string">'合唱团已有成员数量:'</span> + choir.length );</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	joinChoir( duck ); <span class="comment">// 恭喜加入合唱团</span></div><div class="line">	joinChoir( chicken ); <span class="comment">// 恭喜加入合唱团</span></div></pre></td></tr></table></figure>
<p>以上就是一个鸭子类型的代码， 鸡也混入合唱团了，但是没有关系，英雄不问出处，只要你能唱歌就行了。<br>很方便对象方法的调用。 javascript代码中遍布这样的例子，但是现在看来一点也不奇怪了。因为这鸭子类型就是动态语言的优势。而javascript就是动态语言之一，只是实现了这种模式而已。</p>
<p>对于这个问题的认识也破费周折，但是现在看来是值得的。理解了这一点，对javascript的应用能力就更加深了一步。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;冬至来了，刚去吃了一碗萝卜饺子，浑身发热。突然觉得鸭子已经熟了。&lt;/p&gt;
&lt;p&gt;开个玩笑。这里要说的是动态语言的鸭子类型(ducking type)。 &lt;code&gt;这个话题应该是整个javascript面向对象编程的核心思想&lt;/code&gt;.不知道下这个结论对不对？可是在前面
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript的模板方法模式</title>
    <link href="http://yoursite.com/2017/03/19/javascript%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/03/19/javascript的模板方法模式/</id>
    <published>2017-03-19T00:04:10.000Z</published>
    <updated>2017-03-23T12:05:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>模板方法是一种只需要使用继承就可以实现的非常简单的模式<br> 模板方法由两部分组成，一是抽象的父类，二是具体实现的子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。</p>
</blockquote>
<p>参考《javascript模式设计与开发实践》第11章</p>
<p>这个模式方法很有意思,在使用之前需要有一个抽象的额过程，是对类似的生产过程的具体细节的理解，找出流程中的共同点作为抽象的父类。<br>咖啡和茶的冲泡过程</p>
<table>
<thead>
<tr>
<th style="text-align:left">泡<code>咖啡</code></th>
<th style="text-align:left">泡<code>茶</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">把水煮沸</td>
<td style="text-align:left">把水煮沸</td>
</tr>
<tr>
<td style="text-align:left">用沸水<code>泡咖啡</code></td>
<td style="text-align:left">用沸水<code>浸泡茶叶</code></td>
</tr>
<tr>
<td style="text-align:left">把<code>咖啡</code>倒进杯子</td>
<td style="text-align:left">把<code>茶水</code>倒进杯子</td>
</tr>
<tr>
<td style="text-align:left">加<code>糖和牛奶</code></td>
<td style="text-align:left">加<code>柠檬</code></td>
</tr>
</tbody>
</table>
<p>把泡咖啡和泡茶的不同点标示出来，剩下的部分就是共同的部分</p>
<ul>
<li>[ ] 原料不同，一个是咖啡，一个是茶。抽象为饮料</li>
<li>[ ] 泡的方式不同，一个是泡，一个是浸泡。统一抽象为泡</li>
<li>[ ] 加入的调味品不同，一个是糖和牛奶，一个是柠檬。抽象为调料<br>整个冲泡饮料的过程就抽象为下面的流程</li>
</ul>
<ol>
<li>把水煮沸</li>
<li>用沸水冲泡饮料</li>
<li>把饮料倒进被子</li>
<li>加调料</li>
</ol>
<p>抽象的父类的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Beverage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </div><div class="line">Beverage.prototype.boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log( <span class="string">'把水煮沸'</span> );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Beverage.prototype.brew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 空方法，应该由子类重写</span></div><div class="line">Beverage.prototype.pourInCup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 空方法，应该由子类重写</span></div><div class="line">Beverage.prototype.addCondiments = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 空方法，应该由子类重写</span></div><div class="line">Beverage.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//定义子类的函数执行顺序</span></div><div class="line">	<span class="keyword">this</span>.boilWater();</div><div class="line">	<span class="keyword">this</span>.brew();</div><div class="line">	<span class="keyword">this</span>.pourInCup();</div><div class="line">	<span class="keyword">this</span>.addCondiments();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>有了父类的模板，在煮茶是就依照父类的模板来使用，通用部分不动，特殊的地方重写父类的方法</p>
<p>茶叶子类继承父类的模板</p>
<pre><code>var Tea = function(){}; //定义煮茶子类
Tea.prototype = new Beverage(); //继承父类
Tea.prototype.brew = function(){ //重写父类方法
    console.log( &apos;用沸水浸泡茶叶&apos; );
};
Tea.prototype.pourInCup = function(){ 重写父类方法
    console.log( &apos;把茶倒进杯子&apos; );
};
Tea.prototype.addCondiments = function(){ 重写父类方法
    console.log( &apos;加柠檬&apos; );
};
var tea = new Tea(); //实例化子类
tea.init(); //依照父类的方法执行顺序来执行

//由于javascript的对象原型继承链的方式和java的继承是完全不同的，这里代码结构和java类似，但是里面的机制是不同的

<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line"></div><div class="line"><span class="clean">#####钩子方法</span></div><div class="line"></div><div class="line"><span class="number">1.</span> 把水煮沸</div><div class="line"><span class="number">2.</span> 用沸水冲泡饮料</div><div class="line"><span class="number">3.</span> 把饮料倒进被子</div><div class="line"><span class="number">4.</span> 加调料</div><div class="line"></div><div class="line">上面是一般的冲调饮料的流程，但是可能会有特殊情况，比如有的人可能不会加调料。遇到这种情况需要使用`钩子方法`来在隔离有变化的步骤</div></pre></td></tr></table></figure>
</code></pre><p>var Beverage = function(){};<br>    Beverage.prototype.boilWater = function(){<br>        console.log( ‘把水煮沸’ );<br>    };<br>    Beverage.prototype.brew = function(){<br>        throw new Error( ‘子类必须重写brew 方法’ );<br>    };<br>    Beverage.prototype.pourInCup = function(){<br>        throw new Error( ‘子类必须重写pourInCup 方法’ );<br>    };<br>    Beverage.prototype.addCondiments = function(){<br>        throw new Error( ‘子类必须重写addCondiments 方法’ );<br>    };<br>    Beverage.prototype.customerWantsCondiments = function(){<br>        return true; // 默认需要调料<br>    };<br>    Beverage.prototype.init = function(){<br>        this.boilWater();<br>        this.brew();<br>        this.pourInCup();<br>    if ( this.customerWantsCondiments() ){ // 如果挂钩返回true，则需要调料<br>        this.addCondiments(); //第四步就变为可选的方法了<br>    }<br>};<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">实例化冲泡咖啡的实例</div></pre></td></tr></table></figure></p>
<p> var CoffeeWithHook = function(){};<br> CoffeeWithHook.prototype = new Beverage();<br>CoffeeWithHook.prototype.brew = function(){<br>    console.log( ‘用沸水冲泡咖啡’ );<br>};<br>CoffeeWithHook.prototype.pourInCup = function(){<br>    console.log( ‘把咖啡倒进杯子’ );<br>};<br>CoffeeWithHook.prototype.addCondiments = function(){<br>    console.log( ‘加糖和牛奶’ );<br>};<br>CoffeeWithHook.prototype.customerWantsCondiments = function(){<br>    return window.confirm( ‘请问需要调料吗？’ );//对顾客选择的判断条件<br>};<br>var coffeeWithHook = new CoffeeWithHook();</p>
<p>```</p>
<p>模板方法通过封装变化提高系统扩展能力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;模板方法是一种只需要使用继承就可以实现的非常简单的模式&lt;br&gt; 模板方法由两部分组成，一是抽象的父类，二是具体实现的子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。&lt;/p&gt;
&lt;/blockquote
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript组合模式</title>
    <link href="http://yoursite.com/2017/03/18/javascript%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/03/18/javascript组合模式/</id>
    <published>2017-03-17T23:04:10.000Z</published>
    <updated>2017-03-23T12:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在程序设计中，组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也是由更小的对象组成的。这里只是组合，并没有从属关系。参考《javascript设计模式与开发实践》第十章</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//宏命令的代码</span></div><div class="line"><span class="keyword">var</span> closeDoorCommand = &#123;<span class="comment">//作为叶对象</span></div><div class="line">		execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log( <span class="string">'关门'</span> );</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> openPcCommand = &#123; <span class="comment">//作为叶对象</span></div><div class="line">		execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log( <span class="string">'开电脑'</span> );</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> openQQCommand = &#123;<span class="comment">//作为叶对象</span></div><div class="line">		execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log( <span class="string">'登录QQ'</span> );</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="comment">//组合模式的根对象</span></div><div class="line">	<span class="keyword">var</span> MacroCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			<span class="attr">commandsList</span>: [],</div><div class="line">			<span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> command </span>)</span>&#123;<span class="comment">//叶对象作为数组的元素传递到</span></div><div class="line">			<span class="comment">//数组中</span></div><div class="line">				<span class="keyword">this</span>.commandsList.push( command );</div><div class="line">			&#125;,</div><div class="line">			<span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//执行组合命令</span></div><div class="line">				<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, command; command = <span class="keyword">this</span>.commandsList[ i++ ]; )&#123;</div><div class="line">					command.execute(); <span class="comment">//叶对象都有execute方法</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> macroCommand = MacroCommand();</div><div class="line">	macroCommand.add( closeDoorCommand );<span class="comment">//添加到根对象数组中</span></div><div class="line">	macroCommand.add( openPcCommand );<span class="comment">//同上</span></div><div class="line">	macroCommand.add( openQQCommand );<span class="comment">//同上</span></div><div class="line">	macroCommand.execute();<span class="comment">//执行根命令</span></div></pre></td></tr></table></figure>
<p><em>两个要点</em>:1.js对象引用可以作为数组元素加入到数组中。2. 叶对象都有一样的execute方法。在根对象执行的时候，可以使用leaf.execute的模式来调用对象的方法。</p>
<blockquote>
<p>在叶对象中还可以继续扩展也对象，组合的深度继续加深。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MacroCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//根对象的方法保持不变</span></div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			<span class="attr">commandsList</span>: [],</div><div class="line">			<span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> command </span>)</span>&#123;</div><div class="line">				<span class="keyword">this</span>.commandsList.push( command );</div><div class="line">			&#125;,</div><div class="line">			<span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, command; command = <span class="keyword">this</span>.commandsList[ i++ ]; )&#123;</div><div class="line">					command.execute();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> openAcCommand = &#123;</div><div class="line">		<span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log( <span class="string">'打开空调'</span> );</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"><span class="comment">/**********家里的电视和音响是连接在一起的，所以可以用一个宏命令来组合打开电视和打开音响的命令</span></div><div class="line">*********/</div><div class="line"><span class="keyword">var</span> openTvCommand = &#123;</div><div class="line">	<span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="string">'打开电视'</span> );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> openSoundCommand = &#123;</div><div class="line">	<span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="string">'打开音响'</span> );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> macroCommand1 = MacroCommand(); <span class="comment">//第一个叶对象</span></div><div class="line">macroCommand1.add( openTvCommand ); <span class="comment">//添加下一级叶对象</span></div><div class="line">macroCommand1.add( openSoundCommand );<span class="comment">//同上</span></div><div class="line"><span class="comment">/*********关门、打开电脑和打登录QQ 的命令****************/</span></div><div class="line"><span class="keyword">var</span> closeDoorCommand = &#123;</div><div class="line">	<span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="string">'关门'</span> );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> openPcCommand = &#123;</div><div class="line">	<span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="string">'开电脑'</span> );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> openQQCommand = &#123;</div><div class="line">	<span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="string">'登录QQ'</span> );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> macroCommand2 = MacroCommand();<span class="comment">//第二个叶对象</span></div><div class="line">macroCommand2.add( closeDoorCommand );<span class="comment">//添加下一级叶对象</span></div><div class="line">macroCommand2.add( openPcCommand );<span class="comment">//同上</span></div><div class="line">macroCommand2.add( openQQCommand );</div><div class="line"><span class="comment">/*********现在把所有的命令组合成一个“超级命令”**********/</span></div><div class="line"><span class="keyword">var</span> macroCommand = MacroCommand(); <span class="comment">//顶级根对象</span></div><div class="line">macroCommand.add( openAcCommand ); <span class="comment">//一个叶对象</span></div><div class="line">macroCommand.add( macroCommand1 ); <span class="comment">//另一个</span></div><div class="line">macroCommand.add( macroCommand2 ); <span class="comment">//另一个</span></div><div class="line"><span class="comment">/*********最后给遥控器绑定“超级命令”**********/</span></div><div class="line"><span class="keyword">var</span> setCommand = (<span class="function"><span class="keyword">function</span>(<span class="params"> command </span>)</span>&#123;</div><div class="line">	<span class="built_in">document</span>.getElementById( <span class="string">'button'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		command.execute();</div><div class="line">	&#125;</div><div class="line">&#125;)( macroCommand );</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//最终所有的叶对象的引用都添加到commandlist数组中，在根对象上执行</span></div><div class="line"><span class="comment">//execute方法时，会遍历所有的叶对象，并执行leaf.execute()方法。</span></div><div class="line"><span class="comment">//得到结果</span></div></pre></td></tr></table></figure>
<p>#####最终还是使用了javascript的数组操作和对象操作的便利性。在javascript的模式设计中，基本都是在操作数组和对象。所有有必要还好在深刻理解一下数组对象的方法。</p>
<p>这个系列写了好几篇文章了。其实写的时候好多地方还不太懂，写着写着有些地方就明白了，所以还是要坚持写下去。现在觉得写的还不错，过半年可能觉得就很傻了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在程序设计中，组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也是由更小的对象组成的。这里只是组合，并没有从属关系。参考《javascript设计模式与开发实践》第十章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript桥接模式(2)</title>
    <link href="http://yoursite.com/2017/03/17/javascript%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F(2)/"/>
    <id>http://yoursite.com/2017/03/17/javascript桥接模式(2)/</id>
    <published>2017-03-17T13:04:10.000Z</published>
    <updated>2017-03-23T12:12:26.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>事件监听器</li>
<li>桥接模式的其他例子<br>这实际就是一个闭包的例子，通过闭包函数获取外层函数作用域内定义的私有变量。这个函数又可以叫做特权函数，getter函数。这个函数只get不set.       </li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> <span class="keyword">Public</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> secret = <span class="number">3</span>;</div><div class="line">  this.privilegedGetter = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> secret;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="keyword">Public</span>;</div><div class="line"><span class="keyword">var</span> data = o.privilegedGetter();</div></pre></td></tr></table></figure>
<p>3 .  用桥接模式联结多个类.通过下面的方法，如果代码从上往下看是聚合了连个类。在桥接类中统一返回。如果是从下往上看代码，实际是把一个完整的代码拆成了两个独立的类，这样两个独立的类可以修改自己的逻辑，不会影响到另一类的工作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">var</span> Class1 = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">  <span class="keyword">this</span>.b = b;</div><div class="line">  <span class="keyword">this</span>.c = c;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Class2 = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.d = d;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> BridgeClass = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.one = <span class="keyword">new</span> Class1(a, b, c);</div><div class="line">  <span class="keyword">this</span>.two = <span class="keyword">new</span> Class2(d);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>4 . 构建XHR连接队列</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;事件监听器&lt;/li&gt;
&lt;li&gt;桥接模式的其他例子&lt;br&gt;这实际就是一个闭包的例子，通过闭包函数获取外层函数作用域内定义的私有变量。这个函数又可以叫做特权函数，getter函数。这个函数只get不set.       &lt;/li&gt;
&lt;/ol&gt;
&lt;figure cla
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript单例模式(1)</title>
    <link href="http://yoursite.com/2017/03/16/javascript%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(1)/"/>
    <id>http://yoursite.com/2017/03/16/javascript单例模式(1)/</id>
    <published>2017-03-16T00:04:10.000Z</published>
    <updated>2017-03-23T12:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>单例(singleton).这种模式提供了一种将代码组织为一个逻辑单元的手段，可以通过单一变量来访问。通过确保单例对象只有一个拷贝，可以确保代买使用童颜的全局资源。单例可以用来划分命名空间，可以借助单例把代码组织的更为一致，从而更容易阅读和维护。</p>
</blockquote>
<pre><code>本文参照这本书第五章，介绍的重点和另一本书好像是不同的。结合着看看    
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2044710-c97bcd5773f19459.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/320" alt="s3398900.jpg"></p>
<p>####单例的基本结构<br>最基本的就是一个对象字面量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对象字面量作为单体</span></div><div class="line"><span class="keyword">var</span> Singleton = &#123;</div><div class="line">  <span class="attr">attribute1</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">attribute2</span>: <span class="number">10</span>,</div><div class="line"></div><div class="line">  <span class="attr">method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Singleton.attribute1 = <span class="literal">false</span>; <span class="comment">//修改</span></div><div class="line"><span class="keyword">var</span> total = Singleton.attribute2 + <span class="number">5</span>; <span class="comment">//使用单例</span></div><div class="line"><span class="keyword">var</span> result = Singleton.method1();</div></pre></td></tr></table></figure>
<p><code>方法位于对象字面量中就有了命名空间，和其他同名的函数就不会冲突了。对象字面量里的方法统一用  nameSpace.method的格式调用</code><br>对象字面量的命名空间还可以继续划分例如parent.children.method。<br>这样不仅变量发生冲突的机会大大减少，而且归属更明确了。</p>
<p>上面的对象字面量的单例是不是很眼熟？ 在node程序中的配置文件config.js里面是不是都是这种代码？ 配置项都是全局唯一的。</p>
<p>#####惰性实例化<br>本来单例是想写这个内容的，但是今天一看，还是没看全。曾探的js模式书里的单例其实都是这个部分。<code>实际的单例代码放在一个函数中，然后使用一个变量来缓存实例化的代码，如果已经实例化就直接返回缓存的代码。</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">  MyNamespace.Singleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> uniqueInstance; <span class="comment">// 私有变量缓存实例化单例</span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">constructor</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 具体需要按需加载的代码.</span></div><div class="line">    <span class="keyword">var</span> privateAttribute1 = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">var</span> privateAttribute2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod2</span>(<span class="params">args</span>) </span>&#123;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123; <span class="comment">// Public members.</span></div><div class="line">      publicAttribute1: <span class="literal">true</span>,</div><div class="line">      <span class="attr">publicAttribute2</span>: <span class="number">10</span>,</div><div class="line">    </div><div class="line">      <span class="attr">publicMethod1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">publicMethod2</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">getInstance</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span>(!uniqueInstance) &#123; <span class="comment">// 单例若不存在，调用constructor函数</span></div><div class="line">        uniqueInstance = <span class="keyword">constructor</span>(); //调用<span class="keyword">constructor</span>函数后，缓存返回值</div><div class="line">      &#125;</div><div class="line">      return uniqueInstance;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;单例(singleton).这种模式提供了一种将代码组织为一个逻辑单元的手段，可以通过单一变量来访问。通过确保单例对象只有一个拷贝，可以确保代买使用童颜的全局资源。单例可以用来划分命名空间，可以借助单例把代码组织的更为一致，从而更容易阅读和维护。&lt;
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript代理模式</title>
    <link href="http://yoursite.com/2017/03/12/javascript%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/03/12/javascript代理模式/</id>
    <published>2017-03-12T00:04:10.000Z</published>
    <updated>2017-03-23T12:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>代理模式是给对象提供一个代用品或占位符，以便控制对它的访问<br>   参考《javascript模式设计与开发实践》</p>
</blockquote>
<p><code>缓存代理</code></p>
<p>  缓存代理可以为一些开销比较大的运算结果提供暂时的存储，下一次运算时如果传递参数和缓存的参数一致，则可是直接返回前面存储的运算结果</p>
<p>计算乘积的实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//默认传递的arguments参数列表</span></div><div class="line">		<span class="built_in">console</span>.log( <span class="string">'开始计算乘积'</span> );</div><div class="line">		<span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++ )&#123;</div><div class="line">			a = a * <span class="built_in">arguments</span>[i];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> a;</div><div class="line">	&#125;;</div><div class="line">	mult( <span class="number">2</span>, <span class="number">3</span> ); <span class="comment">// 输出：6</span></div><div class="line">	mult( <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ); <span class="comment">// 输出：24</span></div><div class="line">	<span class="comment">//现在加入缓存代理函数：</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> proxyMult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> cache = &#123;&#125;;  <span class="comment">//缓存对象</span></div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>, <span class="string">','</span> ); </div><div class="line">			<span class="keyword">if</span> ( args <span class="keyword">in</span> cache )&#123; <span class="comment">//如果合并的参数在缓存中</span></div><div class="line">				<span class="keyword">return</span> cache[ args ]; <span class="comment">//直接分会缓存数据</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> cache[ args ] = mult.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); </div><div class="line">                        <span class="comment">//调用函数之后存储到缓存对象中</span></div><div class="line">		&#125;</div><div class="line">	&#125;)();</div><div class="line"></div><div class="line">	proxyMult( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ); <span class="comment">// 输出：24  //第一次计算</span></div><div class="line">	proxyMult( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ); <span class="comment">// 输出：24 //第二次计算，直接存缓存中获取</span></div><div class="line"></div><div class="line"><span class="comment">//这里的两个函数，multi负责计算，proxyMulti负责缓存的存储和读取。</span></div><div class="line"><span class="comment">//两个函数分功能完成对应的功能</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;代理模式是给对象提供一个代用品或占位符，以便控制对它的访问&lt;br&gt;   参考《javascript模式设计与开发实践》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;缓存代理&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  缓存代理可以为一些开销比较大的运
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>翻译-使用React构建你的App</title>
    <link href="http://yoursite.com/2017/03/12/%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8React%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84App/"/>
    <id>http://yoursite.com/2017/03/12/翻译-使用React构建你的App/</id>
    <published>2017-03-12T00:04:10.000Z</published>
    <updated>2017-03-23T11:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章时间有点久远,翻译试试看.但是本篇文章对于React的渲染工作原理讲的比较好,使用一个游戏引擎的渲染方式来类比解释React的数据流程,值得学习. <a href="http://konkle.us/architecting-your-app-react-part-1/" target="_blank" rel="external">原文在这里</a></p>
</blockquote>
<p>去年五月(2013年5月),Facebook发布了构建前端组件库的开源软件-React.React对于浏览器和app的结构来说有点异类.但是经过这段时间,开发者逐渐看到了一些优势,React也因此获取了很多的人气.React最为相助的额特征是引入了virtual-DOM方法,virtual-DOM使实际的浏览器的DOM变化减到最低,DOM的渲染性能大幅提高.</p>
<p>React并不是完整的MVC框架,React实际是MVC的加强版(这点,真是雪中送炭,一直都对这个框架到底是不是MVC而心存疑虑).很多开发者选择React作为MVC框架的延伸,例如Backbone.React本身并没有路由和数据同步的内容,所以你可以很容易的使用喜欢的工具来完成类似的功能.React也可以在其他的应用中管理一部分特定的组件.但是如果在应用的界面上全面使用React,发挥的功能会更大.</p>
<p>#####尽可能的避免DOM<br>React作为javascript的一个类,提供virtual-DOM实施方案.这意味着你可以频繁的更新你的应用程序的元素树,但是实际上没有发生浏览器的DOM操作.由于使用了现代的引擎,Javascript的速度相当快.实际由于引擎的速度很快,当每一次数据更新的时候,渲染应用程序的所有元素都是可以的,减少了实时元素操作和双向数据绑定的需求.React周期性的比较virtual-DOM和浏览器DOM,仅仅做出最有必要的DOM同步.</p>
<p>#####单向数据流<br>当HTML元素的渲染花销大幅度降低以后,你现在需要花费更多的的方法来管理你的界面.放弃错综复杂的就地更新元素操作和数据变化中的的多个state的同步,你可以把状态放在一个地方,基于集中的state来描述你的界面.只要状态以改变,React的组件就可以进行更新操作.<br>当你的整个应用都基于这个思想来设计,你可以把immutable 数据从顶层组件传递给子组件,然后执行自顶向下的应用更新.React从根本上改变了你对应用的思路,而且经常会简化应用的设计.</p>
<p>#####浏览器作为渲染引擎<br>这一点是对MVC框架非常激进的改变,它强调使用双向数据绑定,尽可能多自动就地重新渲染.当我刚开始了解React的时候,我还不是太确定.转折点是我看了一个Pete Hunt的视频:比较React和Doom3渲染引擎.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2044710-a1553d287e86aebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="doom3的渲染示意图"><br>在图表中,游戏的sate经过底层的图形代码导入前端逻辑和抽象层.这个操作会创建一个“场景中间表示层”(scene intermediate representation),这个表示层表现出用户应该看到的内容.这个表示层会传递给”backend”(后端),后端接收表示层内容,随之转换为OpenGL操作,OpenGL使用图形卡(电脑显卡)渲染出内容.React的工作原理和Doom3的渲染方式是一样的.(doom3是早期一款比较著名的第一人称射击游戏,这里使用doom3的图形渲染方式来说明React的工作方式).</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2044710-73a98731bc9d6411.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="React组件渲染"></p>
<p>当程序的state由于浏览器或者实时事件发生变化,React程序接收这些变化,并且传递给组件们,接着使用virtual-DOM方式生成中间表示层.浏览器的DOM并不会发生立即的变化.然而React会周期性的接收virtual DOM,计算出必要的DOM操作.这一点和游戏引擎接受场景中间表示层,决定是否使用OpenGL渲染场景类似.React是接收DOM,把它渲染到用户屏幕上.(可见两者渲染的思路是一样的,React使用了浏览器来做这个工作).</p>
<p>浏览器和游戏引擎一样,最慢的部分实际是中间表示层到屏幕的渲染部分.你可以对virtual-DOM做出许多细小的改变,React优化了这个部分,所以不会因此而牺牲渲染的性能.</p>
<p>#####更多的资源<br>在第二部分,我将会演示怎么把React的设计哲学付诸实践.我会分享怎么更具不同的功能责任,渲染一个由小组件组成的顶级组件的界面.我也会演示怎么在React应用中整合路由功能和数据同步功能.</p>
<p>如果你想了解更多的React内容,想知道它是怎么工作的,看看下面的资源列表.</p>
<ul>
<li><a href="http://facebook.github.io/react/" target="_blank" rel="external">React主页</a></li>
<li><a href="http://facebook.github.io/react/docs/videos.html" target="_blank" rel="external">视频</a></li>
<li><a href="http://facebook.github.io/react/docs/examples.html" target="_blank" rel="external">实例</a></li>
<li><a href="https://groups.google.com/forum/#!forum/reactjs" target="_blank" rel="external">React Google Group</a></li>
<li>#reactjs on Freenode-官方 IRC频道,比较活跃</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章时间有点久远,翻译试试看.但是本篇文章对于React的渲染工作原理讲的比较好,使用一个游戏引擎的渲染方式来类比解释React的数据流程,值得学习. &lt;a href=&quot;http://konkle.us/architecting-your-ap
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript开放-封闭原则-NBA常规赛结束</title>
    <link href="http://yoursite.com/2017/03/11/javascript%E5%BC%80%E6%94%BE-%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99-NBA%E5%B8%B8%E8%A7%84%E8%B5%9B%E7%BB%93%E6%9D%9F/"/>
    <id>http://yoursite.com/2017/03/11/javascript开放-封闭原则-NBA常规赛结束/</id>
    <published>2017-03-11T08:04:10.000Z</published>
    <updated>2017-03-23T12:10:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在面向对象程序(OOP)设计中，开放-封闭原则(OCP)是最重要的原则，一个oop的程序具有良好的设计，往往说明它是符合开放-封闭原则的.<br>参考《javascript模式设计与开发实践》第20章<br>首先看一个代码.开放封闭是相互关联的在一段代码中既要体现封闭又要体现开放。封闭不破坏旧功能，开放有可以添加新功能。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面这个函数是修饰模式，在函数运行后添加功能</span></div><div class="line"><span class="comment">//通过这个函数，添加的功能不影响原函数的功能</span></div><div class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params"> afterfn </span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> __self = <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">var</span> ret = __self.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">			afterfn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">			<span class="keyword">return</span> ret;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	<span class="comment">//如果多人开发，都要在window.onload下挂载函数功能(原生的js代码</span></div><div class="line">	<span class="comment">//只能加载一次window.load函数)。很有可能别人也在使用.</span></div><div class="line">	<span class="comment">//要解决这个问题可以结合after函数和函数引用赋值来解决这个问题</span></div><div class="line">	<span class="comment">//如果windoW.load已经挂载有内容，就引用赋值，然后使用after</span></div><div class="line">	<span class="comment">//如果没有使用则直接引用空函数对象，然后挂载after函数</span></div><div class="line">	<span class="comment">//无论哪种情况，通过after函数的</span></div><div class="line">	<span class="built_in">window</span>.onload = ( <span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; ).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="built_in">document</span>.getElementsByTagName( <span class="string">'*'</span> ).length );</div><div class="line">	&#125;);</div></pre></td></tr></table></figure>
<p>但是在实际应用中使用开放-封闭原则很困难，关键是要找到程序在哪里发生变化，这不是一朝一夕之功。所以道理很简单，但是应用起来可能很困难。长路漫漫啊。</p>
<p>至此本人基本把javascript的模式设计的内容过了一遍。可以说收获良多，学到很多东西。阅读代码和分析代码的能力有了提高，好像是在NBA的赛场上，通过解说员的一些战术分析，慢慢看明白了一些跑位和战术，对于一个球迷来说在这种情况下看比赛就不光光是看热闹了，比赛有了更深层次的意义，此时的心情就是有想看更多比赛来验证下一场比赛是否也会出现同样的战术。<br>但这也只是一个起点而已，过一年肯能会觉得现在写的这些文章很幼稚很傻比。就拿这些学习笔记记录这个傻逼的过程吧.</p>
<p>NBA常规赛结束了，还有季后赛和下一赛季等着呢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在面向对象程序(OOP)设计中，开放-封闭原则(OCP)是最重要的原则，一个oop的程序具有良好的设计，往往说明它是符合开放-封闭原则的.&lt;br&gt;参考《javascript模式设计与开发实践》第20章&lt;br&gt;首先看一个代码.开放封闭是相互关联的在一
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript工厂模式-XHR工厂</title>
    <link href="http://yoursite.com/2017/03/11/javascript%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-XHR%E5%B7%A5%E5%8E%82/"/>
    <id>http://yoursite.com/2017/03/11/javascript工厂模式-XHR工厂/</id>
    <published>2017-03-11T00:07:10.000Z</published>
    <updated>2017-03-23T12:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2044710-f56a2c10764090f7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/320" alt="s3398900.jpg"></p>
<blockquote>
<p>一个类或对象中往往包括别的对象。在创建这种成员对象时，你可能习惯于使用常规方式，即用new关键字和类构造函数。问题是这样会导致两个类之间产生依赖性。通过工厂模式可以消除类之间的依赖关系，他使用一个方法来决定究竟要实例化哪个类。参照上图那本书，第7章内容</p>
</blockquote>
<p>#####XHR工厂</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> AjaxHandler = <span class="keyword">new</span> Interface(<span class="string">'AjaxHandler'</span>, [<span class="string">'request'</span>, <span class="string">'createXhrObject'</span>]);</div><div class="line"></div><div class="line"><span class="comment">/* SimpleHandler class. */</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> SimpleHandler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// implements AjaxHandler</span></div><div class="line">SimpleHandler.prototype = &#123;</div><div class="line">  <span class="comment">//request函数负责执行发出的请求和处理相应结果所需的一系列操作</span></div><div class="line">  <span class="comment">//他先使用createXhrObject()函数并对其进行配置，然后发送请求</span></div><div class="line">  request: <span class="function"><span class="keyword">function</span>(<span class="params">method, url, callback, postVars</span>) </span>&#123;</div><div class="line">    <span class="comment">//首次运行或者是没有获得XHR对象时执行具体的方法。</span></div><div class="line">    <span class="comment">//一旦获取了XHR对象，就会缓存起来，后续执行直接从变量引用中获取XHR对象</span></div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">this</span>.createXhrObject();</div><div class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span>(xhr.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</div><div class="line">      (xhr.status === <span class="number">200</span>) ? </div><div class="line">        callback.success(xhr.responseText, xhr.responseXML) : </div><div class="line">        callback.failure(xhr.status);</div><div class="line">    &#125;;</div><div class="line">    xhr.open(method, url, <span class="literal">true</span>);</div><div class="line">    <span class="keyword">if</span>(method !== <span class="string">'POST'</span>) postVars = <span class="literal">null</span>;</div><div class="line">    xhr.send(postVars);</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">//createXhrObject()这个工厂方法根据当前具体环境返回一个XHR对象</span></div><div class="line">  <span class="comment">//首次执行时，他会依次尝试执行三种用于创建XHR对象的方法，一旦遇到</span></div><div class="line">  <span class="comment">//管用的，他就会返回所创建的对象，同时把自己也改为返回的那个对象</span></div><div class="line">  createXhrObject: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//工厂方法.</span></div><div class="line">    <span class="keyword">var</span> methods = [<span class="comment">//三种创建XHR对象的方法组成数组</span></div><div class="line">      <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest(); &#125;,</div><div class="line">      <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'Msxml2.XMLHTTP'</span>); &#125;,</div><div class="line">      <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>); &#125;</div><div class="line">    ];</div><div class="line">    <span class="comment">//下面遍历数组方法，尝试获得XHR对象</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = methods.length; i &lt; len; i++) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        methods[i](); <span class="comment">//尝试获得XHR对象</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span>(e) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// If we reach this point, method[i] worked.</span></div><div class="line">      <span class="comment">//如果运行到这里，数组中有方法可以创建XHR对象</span></div><div class="line">      <span class="keyword">this</span>.createXhrObject = methods[i]; <span class="comment">//直接把对象给第一种可以获取</span></div><div class="line"><span class="comment">//对象的方法，缓存起来      </span></div><div class="line">        <span class="keyword">return</span> methods[i];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// If we reach this point, none of the methods worked.</span></div><div class="line">    <span class="comment">//如果运行到这里，表示没有方法可以使用，抛出错误</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SimpleHandler: Could not create an XHR object.'</span>);</div><div class="line">  &#125; </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* Usage. 具体的使用方法*/</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> myHandler = <span class="keyword">new</span> SimpleHandler(); <span class="comment">//看不到工厂化的过程</span></div><div class="line"><span class="keyword">var</span> callback = &#123; </div><div class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">responseText</span>) </span>&#123; alert(<span class="string">'Success: '</span> + responseText); &#125;, </div><div class="line">  <span class="attr">failure</span>: <span class="function"><span class="keyword">function</span>(<span class="params">statusCode</span>) </span>&#123; alert(<span class="string">'Failure: '</span> + statusCode); &#125; </div><div class="line">&#125;;</div><div class="line">myHandler.request(<span class="string">'GET'</span>, <span class="string">'script.php'</span>, callback);</div></pre></td></tr></table></figure>
<p>createXhrObject()这个函数就是对象工厂方法，由于需要考虑到不同浏览器对于ajax对象的差异性，在获取XHR对象是有根据不同的条件来进行。但是这个<code>根据不同条件实例化XHR对象的方法</code>和实际的<code>ajax请求方法</code>是两个独立的过程。所以在这里把实例化XHR对象的过程封装到一个对象工厂里。在ajax方法中只需要使用XHR对象就可以了。 </p>
<p>两个独立的对象之间实现了解耦和。其实在js模式设计中每种模式基本都是围绕功能的解耦和来展开。要解决问题首先要简化问题，在简化过程中才能识别出模式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2044710-f56a2c10764090f7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/320&quot; a
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript中介者模式-咸鱼网的思考</title>
    <link href="http://yoursite.com/2017/03/11/javascript%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-%E5%92%B8%E9%B1%BC%E7%BD%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2017/03/11/javascript中介者模式-咸鱼网的思考/</id>
    <published>2017-03-10T21:04:10.000Z</published>
    <updated>2017-03-23T12:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在字典里，中介者是指“协助谈判和解决冲突的中立方”。在模式设计里，中介者是一种行为设计模式，它允许我们公开一个统一的接口，系统不同部分可以通过该接口进行通讯。<br>也许一个对象可以和十个对象之间发生联系，十个对象之间有可以发生相互联系，从而形成一张巨大的关系网，要想在这么复杂的关系网中理清关系不是一件容易的事情。<br>中介者模式就是要把对象之间的相互耦合关系解除。通过增加一个中介者对象，每个对象都和中介者对象通讯，对象之间不直接发生联系。<br>中介者对象是的对象之间的网状结构变为一对多的关系。</p>
</blockquote>
<p>拿咸鱼网来说。以前如果我们有闲置的东西，可以在小区的路上摆个摊子，这样看到东西的邻居可能会来买。可是这种关系是十分不稳定和复杂的，交易发生都有偶然性。<br>如果我们把闲置发布到咸鱼，那么发布者和购买者不会直接发生联系。之间的关系都是通过咸鱼来完成的。这样的模式就比直接交易便利的多。</p>
<p>参考《javascript设计模式与开发实践》第14章。《javascript设计模式》动物书 第9章。9.6</p>
<p>看一个简单的例子<br>这是一个捉对厮杀的游戏。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params"> name </span>)</span>&#123; <span class="comment">//玩家构造函数</span></div><div class="line">		<span class="keyword">this</span>.name = name <span class="comment">//玩家名字</span></div><div class="line">		<span class="keyword">this</span>.enemy = <span class="literal">null</span>; <span class="comment">// 敌人</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Player.prototype.win = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//获胜函数</span></div><div class="line">		<span class="built_in">console</span>.log( <span class="keyword">this</span>.name + <span class="string">' won '</span> );</div><div class="line">	&#125;;</div><div class="line">	Player.prototype.lose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//失败函数</span></div><div class="line">		<span class="built_in">console</span>.log( <span class="keyword">this</span>.name +<span class="string">' lost'</span> );</div><div class="line">	&#125;;</div><div class="line">	Player.prototype.die = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//失败函数</span></div><div class="line">		<span class="keyword">this</span>.lose();</div><div class="line">		<span class="keyword">this</span>.enemy.win();</div><div class="line">	&#125;;</div><div class="line">	<span class="comment">//接下来创建2 个玩家对象：</span></div><div class="line">	<span class="keyword">var</span> player1 = <span class="keyword">new</span> Player( <span class="string">'皮蛋'</span> );</div><div class="line">	<span class="keyword">var</span> player2 = <span class="keyword">new</span> Player( <span class="string">'小乖'</span> );</div><div class="line">	<span class="comment">//给玩家相互设置敌人：</span></div><div class="line">	player1.enemy = player2;</div><div class="line">	player2.enemy = player1;</div><div class="line"></div><div class="line">	player1.die();<span class="comment">// 输出：皮蛋 lost、小乖 won</span></div></pre></td></tr></table></figure></p>
<p>这样两个对象之间的相互作用还是比较简单的。<br>当增加玩家组队的时候，就比较复杂了，看看依照上面的思路的代码<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> players = []; <span class="comment">//玩家的数组，使用的时候是二维数组，一维是队颜色</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Player</span></span>( name, teamColor )&#123;<span class="comment">//构造函数</span></div><div class="line">		<span class="built_in">this</span>.partners = []; <span class="comment">// 队友列表</span></div><div class="line">		<span class="built_in">this</span>.enemies = []; <span class="comment">// 敌人列表</span></div><div class="line">		<span class="built_in">this</span>.state = <span class="string">'live'</span>; <span class="comment">// 玩家状态</span></div><div class="line">		<span class="built_in">this</span>.name = name; <span class="comment">// 角色名字</span></div><div class="line">		<span class="built_in">this</span>.teamColor = teamColor; <span class="comment">// 队伍颜色</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Player.prototype.win = <span class="function"><span class="keyword">function</span></span>()&#123; <span class="comment">// 玩家团队胜利</span></div><div class="line">		console.log( <span class="string">'winner: '</span> + <span class="built_in">this</span>.name );</div><div class="line">	&#125;;</div><div class="line">	Player.prototype.lose = <span class="function"><span class="keyword">function</span></span>()&#123; <span class="comment">// 玩家团队失败</span></div><div class="line">		console.log( <span class="string">'loser: '</span> + <span class="built_in">this</span>.name );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Player.prototype.die = <span class="function"><span class="keyword">function</span></span>()&#123; <span class="comment">// 玩家死亡</span></div><div class="line">		<span class="keyword">var</span> all_dead = <span class="literal">true</span>;</div><div class="line"></div><div class="line">		<span class="built_in">this</span>.state = <span class="string">'dead'</span>; <span class="comment">// 设置玩家状态为死亡，标记变量</span></div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, partner; partner = <span class="built_in">this</span>.partners[ i++ ]; )&#123; </div><div class="line">      <span class="comment">// 遍历队友列表</span></div><div class="line">			<span class="keyword">if</span> ( partner.state !== <span class="string">'dead'</span> )&#123; </div><div class="line">    <span class="comment">// 如果还有一个队友没有死亡，则游戏还未失败</span></div><div class="line">				all_dead = <span class="literal">false</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> ( all_dead === <span class="literal">true</span> )&#123; <span class="comment">// 如果队友全部死亡</span></div><div class="line">			<span class="built_in">this</span>.lose(); <span class="comment">// 通知自己游戏失败</span></div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, partner; partner = <span class="built_in">this</span>.partners[ i++ ]; )&#123;</div><div class="line"> <span class="comment">// 通知所有队友玩家游戏失败</span></div><div class="line">				partner.lose();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, enemy; enemy = <span class="built_in">this</span>.enemies[ i++ ]; )&#123;</div><div class="line"> <span class="comment">// 通知所有敌人游戏胜利</span></div><div class="line">				enemy.win();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">var</span> playerFactory = <span class="function"><span class="keyword">function</span></span>( name, teamColor )&#123;<span class="comment">//玩家对象工厂</span></div><div class="line">		<span class="keyword">var</span> <span class="keyword">new</span><span class="type">Player</span> = <span class="keyword">new</span> <span class="type">Player</span>( name, teamColor ); </div><div class="line"><span class="comment">// 创建新玩家</span></div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, player; player = players[ i++ ]; )&#123;</div><div class="line"> <span class="comment">// 通知所有的玩家，有新角色加入</span></div><div class="line">			<span class="keyword">if</span> ( player.teamColor === <span class="keyword">new</span><span class="type">Player</span>.teamColor )&#123; </div><div class="line"><span class="comment">// 如果是同一队的玩家</span></div><div class="line">				player.partners.push( <span class="keyword">new</span><span class="type">Player</span> ); </div><div class="line"><span class="comment">// 相互添加到队友列表</span></div><div class="line">				<span class="keyword">new</span><span class="type">Player</span>.partners.push( player );</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				player.enemies.push( <span class="keyword">new</span><span class="type">Player</span> ); </div><div class="line"><span class="comment">// 相互添加到敌人列表</span></div><div class="line">				<span class="keyword">new</span><span class="type">Player</span>.enemies.push( player );</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		players.push( <span class="keyword">new</span><span class="type">Player</span> );</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span><span class="type">Player</span>;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">//红队：4个玩家</span></div><div class="line">	<span class="keyword">var</span> player1 = playerFactory( <span class="string">'皮蛋'</span>, <span class="string">'red'</span> ),</div><div class="line">	player2 = playerFactory( <span class="string">'小乖'</span>, <span class="string">'red'</span> ),</div><div class="line">	player3 = playerFactory( <span class="string">'宝宝'</span>, <span class="string">'red'</span> ),</div><div class="line">	player4 = playerFactory( <span class="string">'小强'</span>, <span class="string">'red'</span> );</div><div class="line">	<span class="comment">//蓝队：4个玩家</span></div><div class="line">	<span class="keyword">var</span> player5 = playerFactory( <span class="string">'黑妞'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player6 = playerFactory( <span class="string">'葱头'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player7 = playerFactory( <span class="string">'胖墩'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player8 = playerFactory( <span class="string">'海盗'</span>, <span class="string">'blue'</span> );</div><div class="line"></div><div class="line">	player1.die();</div><div class="line">	player2.die();</div><div class="line">	player4.die();</div><div class="line">	player3.die();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上的代码就有点复杂了。当玩家失败(死亡)以后要遍历其他队友等等。加入队伍的时候也比较麻烦，要相互确认。队友之间的相互交叉变化很麻烦。</p>
</blockquote>
<p>下面看看中介者模式改造的代码。<br>重要的是添加了playerDirector这个中介者对象。<br>playerDirector中介者对象中添加接口，receiveMessage()通知中介者来进行相关操作。可以先在中介者对象中看看这个方法<br>reciveMessage( ‘playerDead’, this )；第一个参数是通知中介者的方法。第二个参数就是创建的玩家对象。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line">  <span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>中介者模式<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></div><div class="line"> function Player( name, teamColor )&#123;<span class="comment">//构造函数</span></div><div class="line">		<span class="keyword">this</span>.name = name; <span class="comment">// 角色名字</span></div><div class="line">		<span class="keyword">this</span>.teamColor = teamColor; <span class="comment">// 队伍颜色，玩家数组的第一维</span></div><div class="line">		<span class="keyword">this</span>.state = <span class="string">'alive'</span>; <span class="comment">// 玩家生存状态</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Player.prototype.win = function()&#123;<span class="comment">//胜利</span></div><div class="line">		console.log( <span class="keyword">this</span>.name + <span class="string">' won '</span> );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Player.prototype.lose = function()&#123; <span class="comment">//失败</span></div><div class="line">		console.log( <span class="keyword">this</span>.name +<span class="string">' lost'</span> );</div><div class="line">	&#125;;</div><div class="line">	<span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">****玩家死亡**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></div><div class="line">	Player.prototype.die = function()&#123;</div><div class="line">		<span class="keyword">this</span>.state = <span class="string">'dead'</span>;</div><div class="line">		playerDirector.reciveMessage( <span class="string">'playerDead'</span>, <span class="keyword">this</span> ); </div><div class="line">              <span class="comment">// 给中介者发送消息，玩家死亡</span></div><div class="line">	&#125;;</div><div class="line">	<span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">****移除玩家**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></div><div class="line">	Player.prototype.remove = function()&#123;</div><div class="line">		playerDirector.reciveMessage( <span class="string">'removePlayer'</span>, <span class="keyword">this</span> );     </div><div class="line">               <span class="comment">// 给中介者发送消息，移除一个玩家</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">****玩家换队**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></div><div class="line">	Player.prototype.changeTeam = function( color )&#123;</div><div class="line">		playerDirector.reciveMessage( <span class="string">'changeTeam'</span>, <span class="keyword">this</span>, color );     </div><div class="line">          <span class="comment">// 给中介者发送消息，玩家换队</span></div><div class="line">	&#125;;</div><div class="line">       </div><div class="line">	<span class="keyword">var</span> playerDirector= ( function()&#123; <span class="comment">//中介者构造函数</span></div><div class="line">		<span class="keyword">var</span> players = &#123;&#125;, <span class="comment">// 保存所有玩家</span></div><div class="line">			operations = &#123;&#125;; <span class="comment">// 中介者可以执行的操作</span></div><div class="line">		<span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">*新增一个玩家*</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*/</span></span></div><div class="line">		operations.addPlayer = function( player )&#123;</div><div class="line">			<span class="keyword">var</span> teamColor = player.teamColor; <span class="comment">// 玩家的队伍颜色</span></div><div class="line">			players[ teamColor ] = players[ teamColor ] || []; </div><div class="line">                   <span class="comment">// 如果该颜色的玩家还没有成立队伍，则创建</span></div><div class="line"></div><div class="line">			players[ teamColor ].push( player ); <span class="comment">// 添加玩家进队伍</span></div><div class="line">		&#125;;</div><div class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">*移除一个玩家*</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*/</span></span></div><div class="line">	operations.removePlayer = function( player )&#123;</div><div class="line">		<span class="keyword">var</span> teamColor = player.teamColor, <span class="comment">// 玩家的队伍颜色</span></div><div class="line">		teamPlayers = players[ teamColor ] || []; <span class="comment">// 该队伍所有成员</span></div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">var</span> i = teamPlayers.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- )&#123; <span class="comment">// 遍历删除</span></div><div class="line">			<span class="keyword">if</span> ( teamPlayers[ i ] === player )&#123;</div><div class="line">				teamPlayers.splice( i, <span class="number">1</span> );</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">*玩家换队*</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*/</span></span></div><div class="line">	operations.changeTeam = function( player, newTeamColor )&#123; <span class="comment">// 玩家换队</span></div><div class="line">		operations.removePlayer( player ); <span class="comment">// 从原队伍中删除</span></div><div class="line">		player.teamColor = newTeamColor; <span class="comment">// 改变队伍颜色</span></div><div class="line">		operations.addPlayer( player ); <span class="comment">// 增加到新队伍中</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	operations.playerDead = function( player )&#123; <span class="comment">// 玩家死亡</span></div><div class="line">		<span class="keyword">var</span> teamColor = player.teamColor,</div><div class="line">		teamPlayers = players[ teamColor ]; <span class="comment">// 玩家所在队伍</span></div><div class="line">		<span class="keyword">var</span> all_dead = <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, player; player = teamPlayers[ i++ ]; )&#123;</div><div class="line">			<span class="keyword">if</span> ( player.state !== <span class="string">'dead'</span> )&#123;</div><div class="line">				all_dead = <span class="keyword">false</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> ( all_dead === <span class="keyword">true</span> )&#123; <span class="comment">// 全部死亡</span></div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, player; player = teamPlayers[ i++ ]; )&#123;</div><div class="line">				player.lose(); <span class="comment">// 本队所有玩家lose</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">var</span> color <span class="keyword">in</span> players )&#123;</div><div class="line">				<span class="keyword">if</span> ( color !== teamColor )&#123;</div><div class="line">					<span class="keyword">var</span> teamPlayers = players[ color ]; </div><div class="line">                                         <span class="comment">// 其他队伍的玩家</span></div><div class="line">					<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, player; player = teamPlayers[ i++ ]; )&#123;</div><div class="line">						player.win(); <span class="comment">// 其他队伍所有玩家win</span></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">         </div><div class="line">	   <span class="keyword">var</span> reciveMessage = function()&#123;</div><div class="line">            <span class="comment">//被中介者中使用通知中介者的方法</span></div><div class="line">		<span class="keyword">var</span> message = Array.prototype.shift.call( arguments ); <span class="comment">// arguments 的第一个参数为消息名称</span></div><div class="line">		operations[ message ].apply( <span class="keyword">this</span>, arguments );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		reciveMessage: reciveMessage<span class="comment">//揭示模式的方法</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;)();</div><div class="line"></div><div class="line">	<span class="comment">// 红队：</span></div><div class="line">	<span class="keyword">var</span> player1 = playerFactory( <span class="string">'皮蛋'</span>, <span class="string">'red'</span> ),</div><div class="line">	player2 = playerFactory( <span class="string">'小乖'</span>, <span class="string">'red'</span> ),</div><div class="line">	player3 = playerFactory( <span class="string">'宝宝'</span>, <span class="string">'red'</span> ),</div><div class="line">	player4 = playerFactory( <span class="string">'小强'</span>, <span class="string">'red'</span> );</div><div class="line">	<span class="comment">// 蓝队：</span></div><div class="line">	<span class="keyword">var</span> player5 = playerFactory( <span class="string">'黑妞'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player6 = playerFactory( <span class="string">'葱头'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player7 = playerFactory( <span class="string">'胖墩'</span>, <span class="string">'blue'</span> ),</div><div class="line">	player8 = playerFactory( <span class="string">'海盗'</span>, <span class="string">'blue'</span> );</div><div class="line">	player1.die();</div><div class="line">	player2.die();</div><div class="line">	player3.die();</div><div class="line">	player4.die();</div><div class="line"></div><div class="line">	player1.remove();</div><div class="line">	player2.remove();</div><div class="line">	player3.die();</div><div class="line">	player4.die();</div><div class="line"></div><div class="line">	player1.changeTeam( <span class="string">'blue'</span> );</div><div class="line">	player2.die();</div><div class="line">	player3.die();</div><div class="line">	player4.die();</div></pre></td></tr></table></figure></p>
<p>中介者模式中，使用者之间是不发生任何关系的。发生任何的操作都是通知中介者。中介者再通知其他使用者。<br>使用者之间的耦合解除了。</p>
<p>数组的使用上灵活度很大要注意，其他的地方还是很好理解的。</p>
<p>我感觉react组件和redux模块的相互关系就是中介者模式，您觉得呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在字典里，中介者是指“协助谈判和解决冲突的中立方”。在模式设计里，中介者是一种行为设计模式，它允许我们公开一个统一的接口，系统不同部分可以通过该接口进行通讯。&lt;br&gt;也许一个对象可以和十个对象之间发生联系，十个对象之间有可以发生相互联系，从而形成一
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript发布-订阅者模式</title>
    <link href="http://yoursite.com/2017/03/10/javascript%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/03/10/javascript发布-订阅者模式/</id>
    <published>2017-03-10T00:04:10.000Z</published>
    <updated>2017-03-23T12:07:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这个模式看了很长时间，卡在什么地方呢？在我看来，其他的模式为了简化编程的复杂性，都是鼓励函数或者对象间<code>解耦和</code>的，但是发布-订阅者模式虽然发布者和订阅者对象分开了，但是之间的依赖关系反而更强了。 </p>
</blockquote>
<p><em>关键点</em>：1.订阅者在订阅事件的时候实际是在发布者对象的数组中写入要订阅的事件。 2.发布者在发布或者叫trigger事件的时候，实际是在发布者中遍历数组中订阅者的事件方法。<code>涉及的是消息数组的写入和遍历读出过程</code>。</p>
<p>另外一点就是，由于javascript的函数一类对象，可以直接写入数组，这样咋发布-订阅者模式中操作起来相当的方便，js真是厉害。</p>
<p>关于发布-订阅者模式和观察者模式的区别我没搞懂。这里的例子或许是观察者模式，或许是发布-订阅者模式。</p>
<blockquote>
<p>参考 《javascript设计模式》<code>pro javascript design patterns</code> 第十五章</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//发布者构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Publisher</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.subscribers = []; <span class="comment">//订阅和发布都是围绕这个数组进项</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//执行发布的方法，遍历订阅者对方法</span></div><div class="line">Publisher.prototype.deliver = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.subscribers.forEach(</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">      fn(data);</div><div class="line">    &#125;</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//订阅的方法，订阅者对象写入subscribers数组</span></div><div class="line"><span class="comment">//下面这两个方法挂载在Function原型上</span></div><div class="line"><span class="built_in">Function</span>.prototype.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">publisher</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> alreadyExists = publisher.subscribers.some(</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> ( el === that ) &#123; <span class="comment">//如果已经订阅的话，立即返回</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  );</div><div class="line">  <span class="keyword">if</span> ( !alreadyExists ) &#123; <span class="comment">//订阅者的订阅对象插入数组</span></div><div class="line">    publisher.subscribers.push(<span class="keyword">this</span>);<span class="comment">//注意命名空间</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//取消订阅的方法</span></div><div class="line"><span class="built_in">Function</span>.prototype.unsubscribe = <span class="function"><span class="keyword">function</span>(<span class="params">publisher</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">  publisher.subscribers = publisher.subscribers.filter(</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> ( el !== that ) &#123; <span class="comment">//如果是订阅对象就过滤掉</span></div><div class="line">        <span class="keyword">return</span> el;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> publisherObject = <span class="keyword">new</span> Publisher;<span class="comment">//发布者对象</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> observerObject = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;<span class="comment">//订阅者对象 </span></div><div class="line">  <span class="comment">// process data</span></div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">  <span class="comment">// unsubscribe from this publisher</span></div><div class="line">  <span class="built_in">arguments</span>.callee.unsubscribe(publisherObject);</div><div class="line">  <span class="comment">//在订阅对象中取消订阅，其实就是只执行一次发布操作</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">observerObject.subscribe(publisherObject);  </div><div class="line"><span class="comment">//执行订阅，注意这个订阅方法挂载的原型，我开始搞混了，以为代码有错</span></div></pre></td></tr></table></figure>
<blockquote>
<p>js的数组操作和高阶函数的特性使得发布-订阅者模式很好实现。<br>  这个模式我在react/redux的数据流程中觉得是有的，但是反而在模式学习中是最难的。解耦和也不是绝对的一点联系都没有，关系是<code>藕断丝连</code>，要看到断开的<code>两节藕</code>，还要看到之间的的<code>丝</code>.react/redux的学习中就要找到这层关系。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个模式看了很长时间，卡在什么地方呢？在我看来，其他的模式为了简化编程的复杂性，都是鼓励函数或者对象间&lt;code&gt;解耦和&lt;/code&gt;的，但是发布-订阅者模式虽然发布者和订阅者对象分开了，但是之间的依赖关系反而更强了。 &lt;/p&gt;
&lt;/blockqu
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javscript" scheme="http://yoursite.com/tags/javscript/"/>
    
  </entry>
  
  <entry>
    <title>javascript适配器模式</title>
    <link href="http://yoursite.com/2017/03/10/javascript%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/03/10/javascript适配器模式/</id>
    <published>2017-03-09T17:04:10.000Z</published>
    <updated>2017-03-23T12:15:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>适配器模式是为了解决软件实体间的接口不兼容性。使用适配器以后原本不兼容的两个软件的接口可以工作在一起了。<br>宗旨是不要改变原软件接口的程序代码，在外部使用适配器对数据结构做调整。<br>参考《javascript模式设计与开发实践》第17章</p>
</blockquote>
<p>第一段代码，两个地图接口之间的适配</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> googleMap = &#123;</div><div class="line">		<span class="attr">show</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)方法是<span class="title">show</span></span></div><div class="line">			<span class="title">console</span>.<span class="title">log</span>(<span class="params"> <span class="string">'开始渲染谷歌地图'</span> </span>);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="title">var</span> <span class="title">baiduMap</span> = &#123;</div><div class="line">		display: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//方法是display</span></div><div class="line">			<span class="built_in">console</span>.log( <span class="string">'开始渲染百度地图'</span> );</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> baiduMapAdapter = &#123;</div><div class="line">		<span class="attr">show</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//适配器也改为show,返回的是display</span></div><div class="line">			<span class="keyword">return</span> baiduMap.display();</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="comment">//下面是渲染地图的方法，传入地图对象</span></div><div class="line">	<span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params"> map </span>)</span>&#123;<span class="comment">//传入地图对象</span></div><div class="line">		<span class="keyword">if</span> ( map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span> )&#123; <span class="comment">//判断</span></div><div class="line">			map.show();  <span class="comment">//地图对象的show方法</span></div><div class="line">			<span class="comment">//在传入baiduMapAdapter对象的时候，调用show方法，返回的</span></div><div class="line">			<span class="comment">//实际是baiduMap的display方法。</span></div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	renderMap( googleMap ); <span class="comment">// 输出：开始渲染谷歌地图</span></div><div class="line">	renderMap( baiduMapAdapter ); <span class="comment">// 输出：开始渲染百度地图 </span></div><div class="line"> </div><div class="line"> <span class="string">``</span><span class="string">`   </span></div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">数据结构如果不同，也可以不要改动API的输出代码，只改动输出以后的数据呈现结构</div></pre></td></tr></table></figure>
<p> //其中一个API返回的数据<br> var getGuangdongCity = function(){<br>        var guangdongCity = [<br>        {<br>            name: ‘shenzhen’,<br>            id: 11,<br>        }, {<br>            name: ‘guangzhou’,<br>            id: 12,<br>        }<br>        ];<br>        return guangdongCity;<br>    };<br>    var render = function( fn ){<br>        console.log( ‘开始渲染广东省地图’ );<br>        document.write( JSON.stringify( fn() ) );<br>    };<br>    render( getGuangdongCity );</p>
<pre><code>//另一个api获得的数据
var guangdongCity = {
    shenzhen: 11,
    guangzhou: 12,
    zhuhai: 13
};

//这两个API返回的数据不同，不需要改动API的输出代码，要在输
</code></pre><p>//出以后做适配。 我们自己的API可以改动，但是如果是第三方的API就<br>//没有办法要求改动输出结构。所以最好是做适配。这个过程可能很复杂，这里只是说明有这个思路。</p>
<pre><code><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//new data</span></div><div class="line">  <span class="built_in">var</span> guangdongCity = &#123;</div><div class="line">	<span class="attribute">shenzhen</span>: <span class="number">11</span>,</div><div class="line">	<span class="attribute">guangzhou</span>: <span class="number">12</span>,</div><div class="line">	<span class="attribute">zhuhai</span>: <span class="number">13</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//按照需要把下面的输出格式改为上面代码里的格式</span></div><div class="line"><span class="comment">//old data</span></div><div class="line"><span class="built_in">var</span> getGuangdongCity = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">var</span> guangdongCity = [</div><div class="line">	&#123;</div><div class="line">		<span class="attribute">name</span>: <span class="string">'shenzhen'</span>,</div><div class="line">		<span class="attribute">id:</span><span class="string"> 11,</span></div><div class="line">	&#125;, &#123;</div><div class="line">		name: <span class="string">'guangzhou'</span>,</div><div class="line">		<span class="attribute">id:</span><span class="string"> 12,</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	];</div><div class="line">	return guangdongCity;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//新旧数据统一的渲染方法</span></div><div class="line"><span class="built_in">var</span> render = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log( <span class="string">'开始渲染广东省地图'</span> );</div><div class="line">	<span class="built_in">document</span>.write( <span class="built_in">JSON</span>.stringify( fn() ) );</div><div class="line">&#125;;</div><div class="line"> <span class="comment">//输出数据结构的适配器，把旧数据按照新数据结构的格式做适配</span></div><div class="line"><span class="built_in">var</span> addressAdapter = <span class="function"><span class="keyword">function</span>(<span class="params"> oldAddressfn </span>)</span>&#123;</div><div class="line">	<span class="built_in">var</span> address = &#123;&#125;,</div><div class="line">	oldAddress = oldAddressfn();<span class="comment">//获取就数据</span></div><div class="line">	<span class="comment">//适配的具体代码</span></div><div class="line">	<span class="keyword">for</span> ( <span class="built_in">var</span> i = <span class="number">0</span>, c; c = oldAddress[ i++ ]; )&#123;</div><div class="line">		address[ c.name ] = c.id;由数组对象改为对象存储</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> address;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//通过适配器渲染旧数据，输出的是新数据的结构</span></div><div class="line">render( addressAdapter( getGuangdongCity ) );</div></pre></td></tr></table></figure>
</code></pre><p>  就我个人来看， 适配器的思路是最简单的，但是实际操作起来可能是最复杂的，数据之间的适配可能比想象中的麻烦很多。但是了解到这个思路对于编程的灵活性有了认识，如果是以前可能遇到这样的问题的时候，首先考虑到的是怎么去修改原来的的代码。一个小思路，方法完全不同了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;适配器模式是为了解决软件实体间的接口不兼容性。使用适配器以后原本不兼容的两个软件的接口可以工作在一起了。&lt;br&gt;宗旨是不要改变原软件接口的程序代码，在外部使用适配器对数据结构做调整。&lt;br&gt;参考《javascript模式设计与开发实践》第17章&lt;/
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>翻译-Redux的中间件-Reselect</title>
    <link href="http://yoursite.com/2017/03/09/%E7%BF%BB%E8%AF%91-Redux%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6-Reselect/"/>
    <id>http://yoursite.com/2017/03/09/翻译-Redux的中间件-Reselect/</id>
    <published>2017-03-09T00:04:10.000Z</published>
    <updated>2017-03-23T11:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>本文是翻译Redux的一个中间件文档.Redux是React的一个数据层,React组件的state有关逻辑处理都被单独放到Redux中来进行,在state的操作流程中衍生了很多中间件,Reselect这个中间件要解决的问题是:`在组件交互操作的时候,state发生变化的时候如何减少渲染的压力.在Reselect中间中使用了缓存机制,这个机制可以在javascript的模式设计中刚看到介绍,这里就不详细说了.</strong>仅供参考,以原文为准.</p>
<hr>
<p>一旦redux从react的数据层来理解，很多问题都似乎找到了理论依据，所谓名正言顺。在web框架中都会用数据库做数据持久层，在查表的时候会为了效率做缓存，reselect是同样的目的。React的组件有自己的特殊性，遇到特殊的特性的时候需要有特殊的处理<br>方法.</p>
</blockquote>
<p>以下是译文内容,<a href="https://github.com/reactjs/reselect" target="_blank" rel="external">原文请参见</a></p>
<hr>
<blockquote>
<p>“selector”是一个简单的Redux库,灵感来源于<code>NuclearJS</code>.</p>
<ul>
<li>Selector可以计算衍生的数据,可以让Redux做到存储尽可能少的state。</li>
<li>Selector比较高效,只有在某个参数发生变化的时候才发生计算过程.</li>
<li>Selector是可以组合的,他们可以作为输入,传递到其他的selector.</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个例子不必太在意,后面会有详细的介绍</span></div><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> shopItemsSelector = <span class="function"><span class="params">state</span> =&gt;</span> state.shop.items</div><div class="line"><span class="keyword">const</span> taxPercentSelector = <span class="function"><span class="params">state</span> =&gt;</span> state.shop.taxPercent</div><div class="line"></div><div class="line"><span class="keyword">const</span> subtotalSelector = createSelector(</div><div class="line">  shopItemsSelector,</div><div class="line">  items =&gt; items.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc + item.value, <span class="number">0</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> taxSelector = createSelector(</div><div class="line">  subtotalSelector,</div><div class="line">  taxPercentSelector,</div><div class="line">  (subtotal, taxPercent) =&gt; subtotal * (taxPercent / <span class="number">100</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> totalSelector = createSelector(</div><div class="line">  subtotalSelector,</div><div class="line">  taxSelector,</div><div class="line">  (subtotal, tax) =&gt; (&#123; <span class="attr">total</span>: subtotal + tax &#125;)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">let</span> exampleState = &#123;</div><div class="line">  <span class="attr">shop</span>: &#123;</div><div class="line">    <span class="attr">taxPercent</span>: <span class="number">8</span>,</div><div class="line">    <span class="attr">items</span>: [</div><div class="line">      &#123; <span class="attr">name</span>: <span class="string">'apple'</span>, <span class="attr">value</span>: <span class="number">1.20</span> &#125;,</div><div class="line">      &#123; <span class="attr">name</span>: <span class="string">'orange'</span>, <span class="attr">value</span>: <span class="number">0.95</span> &#125;,</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(subtotalSelector(exampleState)) <span class="comment">// 2.15</span></div><div class="line"><span class="built_in">console</span>.log(taxSelector(exampleState))      <span class="comment">// 0.172</span></div><div class="line"><span class="built_in">console</span>.log(totalSelector(exampleState))    <span class="comment">// &#123; total: 2.322 &#125;</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li><a href="#安装">Installation</a></li>
<li><a href="#实例">实例</a><ul>
<li><a href="#motivation-for-memoized-selectors">Motivation for Memoized Selectors</a></li>
<li><a href="#creating-a-memoized-selector">Creating a Memoized Selector</a></li>
<li><a href="#composing-selectors">Composing Selectors</a></li>
<li><a href="#connecting-a-selector-to-the-redux-store">Connecting a Selector to the Redux Store</a></li>
<li><a href="#accessing-react-props-in-selectors">Accessing React Props in Selectors</a></li>
<li><a href="#sharing-selectors-with-props-across-multiple-components">Sharing Selectors with Props Across Multiple Components</a></li>
</ul>
</li>
<li><a href="#api">API</a><ul>
<li><a href="#createselectorinputselectors--inputselectors-resultfunc"><code>createSelector</code></a></li>
<li><a href="#defaultmemoizefunc-equalitycheck--defaultequalitycheck"><code>defaultMemoize</code></a></li>
<li><a href="#createselectorcreatormemoize-memoizeoptions"><code>createSelectorCreator</code></a></li>
<li><a href="#createstructuredselectorinputselectors-selectorcreator--createselector"><code>createStructuredSelector</code></a></li>
</ul>
</li>
<li><p><a href="#faq">FAQ</a></p>
<ul>
<li><a href="#q-why-isnt-my-selector-recomputing-when-the-input-state-changes">Why isn’t my selector recomputing when the input state changes?</a></li>
<li><a href="#q-why-is-my-selector-recomputing-when-the-input-state-stays-the-same">Why is my selector recomputing when the input state stays the same?</a></li>
<li><a href="#q-can-i-use-reselect-without-redux">Can I use Reselect without Redux?</a></li>
<li><a href="#q-the-default-memoization-function-is-no-good-can-i-use-a-different-one">The default memoization function is no good, can I use a different one?</a></li>
<li><a href="#q-how-do-i-test-a-selector">How do I test a selector?</a></li>
<li><a href="#q-how-do-i-create-a-selector-that-takes-an-argument">How do I create a selector that takes an argument? </a></li>
<li><a href="#q-how-do-i-use-reselect-with-immutablejs">How do I use Reselect with Immutable.js?</a></li>
<li><a href="#q-can-i-share-a-selector-across-multiple-components">Can I share a selector across multiple components?</a></li>
<li><a href="#q-are-there-typescript-typings">Are there TypeScript typings?</a></li>
<li><a href="#q-how-can-i-make-a-curried-selector">How can I make a curried selector?</a></li>
</ul>
</li>
<li><p><a href="#related-projects">Related Projects</a></p>
</li>
<li><a href="#license">License</a><br>##安装<br><code>npm install reselect</code></li>
</ul>
<p>##实例</p>
<p>###缓存Selcectos的动机</p>
<blockquote>
<p>实例是基于 <a href="http://redux.js.org/docs/basics/UsageWithReact.html" target="_blank" rel="external">Redux Todos List example</a>.</p>
</blockquote>
<h4 id="containers-VisibleTodoList-js"><a href="#containers-VisibleTodoList-js" class="headerlink" title="containers/VisibleTodoList.js"></a><code>containers/VisibleTodoList.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; toggleTodo &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></div><div class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../components/TodoList'</span></div><div class="line"></div><div class="line"><span class="comment">//下面这段代码是根据过滤器的state来改变日程state的函数</span></div><div class="line"><span class="keyword">const</span> getVisibleTodos = <span class="function">(<span class="params">todos, filter</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">switch</span> (filter) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'SHOW_ALL'</span>:</div><div class="line">      <span class="keyword">return</span> todos</div><div class="line">    <span class="keyword">case</span> <span class="string">'SHOW_COMPLETED'</span>:</div><div class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> t.completed)</div><div class="line">    <span class="keyword">case</span> <span class="string">'SHOW_ACTIVE'</span>:</div><div class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> !t.completed)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">//todos是根据过滤函数返回的state，传入两个实参</span></div><div class="line">    todos: getVisibleTodos(state.todos, state.visibilityFilter)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//mapDispatchToProps来传递dispatch的方法</span></div><div class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">onTodoClick</span>: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</div><div class="line">      dispatch(toggleTodo(id))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用Redux的connect函数注入state,到TodoList组件</span></div><div class="line"><span class="keyword">const</span> VisibleTodoList = connect(</div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(TodoList)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> VisibleTodoList</div></pre></td></tr></table></figure>
<hr>
<p>在上面的例子中,<code>mapStateToProps</code>调用<code>getVisibleTodos</code>去计算<code>todos</code>.这个函数设计的是相当好的,但是有个缺点：<code>todos</code>在每一次组件更新的时候都会重新计算.如果state树的结构比较大,或者计算比较昂贵,每一次组件更新的时候都进行计算的话,将会导致性能问题.<code>Reselect</code>能够帮助redux来避免不必要的重新计算过程.</p>
<p>###创建一个缓存Selector<br>我们可以使用记忆缓存selector代替<code>getVisibleTodos</code>,如果<code>state.todos</code>和<code>state.visibilityFilter</code>发生变化,他会重新计算<code>state</code>,但是发生在其他部分的state变化,就不会重新计算.</p>
<p>Reslect提供一个函数<code>createSelector</code>来创建一个记忆selectors.<code>createSelector</code>接受一个<code>input-selectors</code>和一个变换函数作为参数.如果Redux的state发生改变造成<code>input-selector</code>的值发生改变,selector会调用变换函数,依据<code>input-selector</code>做参数,返回一个结果.如果<code>input-selector</code>返回的结果和前面的一样,那么就会直接返回有关state,会省略变换函数的调用.</p>
<p>下面我们定义一个记忆selector<code>getVisibleTodos</code>替代非记忆的版本</p>
<h4 id="selectors-index-js"><a href="#selectors-index-js" class="headerlink" title="selectors/index.js"></a><code>selectors/index.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> getVisibilityFilter = <span class="function">(<span class="params">state</span>) =&gt;</span> state.visibilityFilter</div><div class="line"><span class="keyword">const</span> getTodos = <span class="function">(<span class="params">state</span>) =&gt;</span> state.todos</div><div class="line"><span class="comment">//下面的函数是经过包装的</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> getVisibleTodos = createSelector(</div><div class="line">  [ getVisibilityFilter, getTodos ],</div><div class="line">  (visibilityFilter, todos) =&gt; &#123;</div><div class="line">    <span class="keyword">switch</span> (visibilityFilter) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'SHOW_ALL'</span>:</div><div class="line">        <span class="keyword">return</span> todos</div><div class="line">      <span class="keyword">case</span> <span class="string">'SHOW_COMPLETED'</span>:</div><div class="line">        <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> t.completed)</div><div class="line">      <span class="keyword">case</span> <span class="string">'SHOW_ACTIVE'</span>:</div><div class="line">        <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> !t.completed)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>上面的的实例中,<code>getVisibilityfilter</code>和<code>getTodos</code>是input-selectors.这两个函数是普通的非记忆selector函数,因为他们没有变换他们select的数据.<code>getVisibleTodos</code>另一方面是一个记忆selector.他接收<code>getVisibilityfilter</code>和<code>getTodos</code>作为input-selectors,并且作为一个变换函数计算筛选的todo list.</p>
<p>###聚合selectors</p>
<p>一个记忆性selector本身也可以作为另一个记忆性selector的input-selector.这里<code>getVisibleTodos</code>可以作为input-selector作为关键字筛选的input-selector:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> getKeyword = <span class="function">(<span class="params">state</span>) =&gt;</span> state.keyword</div><div class="line"></div><div class="line"><span class="keyword">const</span> getVisibleTodosFilteredByKeyword = createSelector(</div><div class="line">  [ getVisibleTodos, getKeyword ],</div><div class="line">  (visibleTodos, keyword) =&gt; visibleTodos.filter(</div><div class="line">    <span class="function"><span class="params">todo</span> =&gt;</span> todo.text.indexOf(keyword) &gt; <span class="number">-1</span></div><div class="line">  )</div><div class="line">)</div></pre></td></tr></table></figure></p>
<hr>
<p>###连接一个Selector到Redux Store<br>如果你正在使用 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">React Redux</a>, 你可以直接传递selector到 <code>mapStateToProps()</code>:</p>
<h4 id="containers-VisibleTodoList-js-1"><a href="#containers-VisibleTodoList-js-1" class="headerlink" title="containers/VisibleTodoList.js"></a><code>containers/VisibleTodoList.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; toggleTodo &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></div><div class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../components/TodoList'</span></div><div class="line"><span class="keyword">import</span> &#123; getVisibleTodos &#125; <span class="keyword">from</span> <span class="string">'../selectors'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">todos</span>: getVisibleTodos(state)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">onTodoClick</span>: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</div><div class="line">      dispatch(toggleTodo(id))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> VisibleTodoList = connect(</div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(TodoList)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> VisibleTodoList</div></pre></td></tr></table></figure>
<hr>
<p>###在React Props中接入Selectors</p>
<blockquote>
<p>这一部分我们假设程序将会有一个扩展,我们允许selector支持多todo List.请注意如果要完全实施这个扩展,reducers,components,actions等等都需要作出改变.这些内容和主题不是太相关,所以这里就省略掉了.</p>
</blockquote>
<p>目前为止,我们仅仅看到selectors接收store的state作为一个参数,其实一个selector叶可以接受props.</p>
<p>这里是一个<code>App</code>组件,渲染出三个<code>VisibleTodoList</code>组件,每一个组件有<code>ListId</code>属性.</p>
<h4 id="components-App-js"><a href="#components-App-js" class="headerlink" title="components/App.js"></a><code>components/App.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">'./Footer'</span></div><div class="line"><span class="keyword">import</span> AddTodo <span class="keyword">from</span> <span class="string">'../containers/AddTodo'</span></div><div class="line"><span class="keyword">import</span> VisibleTodoList <span class="keyword">from</span> <span class="string">'../containers/VisibleTodoList'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;VisibleTodoList listId="1" /&gt;</div><div class="line">    &lt;VisibleTodoList listId="2" /&gt;</div><div class="line">    &lt;VisibleTodoList listId="3" /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>每一个<code>VisibleTodoList</code>container应该根据各自的<code>listId</code>属性获取state的不同部分.所以我们修改一下<code>getVisibilityFilter</code>和<code>getTodos</code>,便于接受一个属性参数</p>
<h4 id="selectors-todoSelectors-js"><a href="#selectors-todoSelectors-js" class="headerlink" title="selectors/todoSelectors.js"></a><code>selectors/todoSelectors.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> getVisibilityFilter = <span class="function">(<span class="params">state, props</span>) =&gt;</span></div><div class="line">  state.todoLists[props.listId].visibilityFilter</div><div class="line"></div><div class="line"><span class="keyword">const</span> getTodos = <span class="function">(<span class="params">state, props</span>) =&gt;</span></div><div class="line">  state.todoLists[props.listId].todos <span class="comment">//这里是为二维数组了</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> getVisibleTodos = createSelector(</div><div class="line">  [ getVisibilityFilter, getTodos ],</div><div class="line">  (visibilityFilter, todos) =&gt; &#123;</div><div class="line">    <span class="keyword">switch</span> (visibilityFilter) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'SHOW_COMPLETED'</span>:</div><div class="line">        <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed)</div><div class="line">      <span class="keyword">case</span> <span class="string">'SHOW_ACTIVE'</span>:</div><div class="line">        <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> todos</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> getVisibleTodos</div></pre></td></tr></table></figure>
<hr>
<p><code>props</code>可以从<code>mapStateToProps</code>传递到<code>getVisibleTodos</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">todos</span>: getVisibleTodos(state, props)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>现在<code>getVisibleTodos</code>可以获取<code>props</code>,每一部分似乎都工作的不错.</p>
<p><em>**但是还有个问题</em><br>当<code>getVisibleTodos</code>selector和<code>VisibleTodoList</code>container的多个实例一起工作的时候,记忆功能就不能正常的运行:</p>
<h4 id="containers-VisibleTodoList-js-2"><a href="#containers-VisibleTodoList-js-2" class="headerlink" title="containers/VisibleTodoList.js"></a><code>containers/VisibleTodoList.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; toggleTodo &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></div><div class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../components/TodoList'</span></div><div class="line"><span class="keyword">import</span> &#123; getVisibleTodos &#125; <span class="keyword">from</span> <span class="string">'../selectors'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">// WARNING: THE FOLLOWING SELECTOR DOES NOT CORRECTLY MEMOIZE</span></div><div class="line">    <span class="comment">//⚠️下面的selector不能正确的记忆</span></div><div class="line">    todos: getVisibleTodos(state, props)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">onTodoClick</span>: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</div><div class="line">      dispatch(toggleTodo(id))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> VisibleTodoList = connect(</div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(TodoList)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> VisibleTodoList</div></pre></td></tr></table></figure>
<hr>
<p>使用<code>createSelector</code>创建的selector时候,如果他的参数集合和上一次的参数机会是一样的,仅仅返回缓存的值.如果我们交替渲染<code>&lt;VisibleTodoList listId=&quot;1&quot; /&gt;</code> 和<code>&lt;VisibleTodoList listId=&quot;2&quot; /&gt;</code>时,共享的selector将会交替接受<code>{listId：1}</code>和<code>{listId:2}</code>作为他的props的参数.这将会导致每一次调用的时候的参数都不同,因此selector每次都会重新来计算而不是返回缓存的值.下一部分我们将会介绍怎么解决这个问题.</p>
<p>###跨越多个组件使用selectors共性props</p>
<blockquote>
<p>这一部分的实例需要React Redux v4.3.0或者更高版本的支持.</p>
</blockquote>
<p>在多个<code>VisibleTodoList</code>组件中共享selector,同时还要<strong>保持</strong>记忆性,每一个组件的实例需要他们自己的selector备份.</p>
<p>现在让我们创建一个函数<code>makeGetVisibleTodos</code>,这个函数每次调用的时候返回一个新的<code>getVisibleTodos</code>的拷贝:</p>
<h4 id="selectors-todoSelectors-js-1"><a href="#selectors-todoSelectors-js-1" class="headerlink" title="selectors/todoSelectors.js"></a><code>selectors/todoSelectors.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> getVisibilityFilter = <span class="function">(<span class="params">state, props</span>) =&gt;</span></div><div class="line">  state.todoLists[props.listId].visibilityFilter</div><div class="line"></div><div class="line"><span class="keyword">const</span> getTodos = <span class="function">(<span class="params">state, props</span>) =&gt;</span></div><div class="line">  state.todoLists[props.listId].todos</div><div class="line"></div><div class="line"><span class="keyword">const</span> makeGetVisibleTodos = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> createSelector(</div><div class="line">    [ getVisibilityFilter, getTodos ],</div><div class="line">    (visibilityFilter, todos) =&gt; &#123;</div><div class="line">      <span class="keyword">switch</span> (visibilityFilter) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'SHOW_COMPLETED'</span>:</div><div class="line">          <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed)</div><div class="line">        <span class="keyword">case</span> <span class="string">'SHOW_ACTIVE'</span>:</div><div class="line">          <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">          <span class="keyword">return</span> todos</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> makeGetVisibleTodos</div></pre></td></tr></table></figure>
<hr>
<p>我们也需要设置给每一个组件的实例他们各自获取私有的selector方法.<code>mapStateToProps</code>的<code>connect</code>函数可以帮助完成这个功能.</p>
<p><em>**如果<code>mapStateToProps</code>提供给<code>connect</code>不返回一个对象而是一个函数,他就可以被用来为每个组件container创建一个私有的<code>mapStateProps</code>函数.</em></p>
<p>在下面的实例中,<code>mapStateProps</code>创建一个新的<code>getVisibleTodos</code>selector,他返回一个<code>mapStateToProps</code>函数,这个函数能够接入新的selector.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeMapStateToProps = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> getVisibleTodos = makeGetVisibleTodos()</div><div class="line">  <span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">todos</span>: getVisibleTodos(state, props)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> mapStateToProps</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>如果我们把<code>makeMapStateToprops</code>传递到<code>connect</code>,每一个<code>visibleTodoList</code>container将会获得各自的含有私有<code>getVisibleTodos</code>selector的<code>mapStateToProps</code>的函数.这样一来记忆就正常了,不管<code>VisibleTodoList</code>containers的渲染顺序怎么样.</p>
<h4 id="containers-VisibleTodoList-js-3"><a href="#containers-VisibleTodoList-js-3" class="headerlink" title="containers/VisibleTodoList.js"></a><code>containers/VisibleTodoList.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; toggleTodo &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></div><div class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../components/TodoList'</span></div><div class="line"><span class="keyword">import</span> &#123; makeGetVisibleTodos &#125; <span class="keyword">from</span> <span class="string">'../selectors'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> makeMapStateToProps = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> getVisibleTodos = makeGetVisibleTodos()</div><div class="line">  <span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">todos</span>: getVisibleTodos(state, props)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> mapStateToProps</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">onTodoClick</span>: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</div><div class="line">      dispatch(toggleTodo(id))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> VisibleTodoList = connect(</div><div class="line">  makeMapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(TodoList)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> VisibleTodoList</div></pre></td></tr></table></figure>
<hr>
<p>##API</p>
<p>###createSelector(…inputSelectors|[inputSelectors],resultFunc)</p>
<p>接受一个或者多个selectors,或者一个selectors数组,计算他们的值并且作为参数传递给<code>resultFunc</code>.</p>
<p><code>createSelector</code>通过判断input-selector之前调用和之后调用的返回值的全等于(===,这个地方英文文献叫reference equality,引用等于,这个单词是本质,中文没有翻译出来).经过<code>createSelector</code>创建的selector应该是immutable(不变的).</p>
<p>经过<code>createSelector</code>创建的Selectors有一个缓存,大小是1.这意味着当一个input-selector变化的时候,他们总是会重新计算state,因为Selector仅仅存储每一个input-selector前一个值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mySelector = createSelector(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.values.value1,</div><div class="line">  state =&gt; state.values.value2,</div><div class="line">  (value1, value2) =&gt; value1 + value2</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// You can also pass an array of selectors</span></div><div class="line"><span class="comment">//可以出传递一个selector数组</span></div><div class="line"><span class="keyword">const</span> totalSelector = createSelector(</div><div class="line">  [</div><div class="line">    <span class="function"><span class="params">state</span> =&gt;</span> state.values.value1,</div><div class="line">    state =&gt; state.values.value2</div><div class="line">  ],</div><div class="line">  (value1, value2) =&gt; value1 + value2</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>在selector内部获取一个组件的props非常有用.当一个selector通过<code>connect</code>函数连接到一个组件上,组件的属性作为第二个参数传递给selector:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> abSelector = <span class="function">(<span class="params">state, props</span>) =&gt;</span> state.a * props.b</div><div class="line"></div><div class="line"><span class="comment">// props only (ignoring state argument)</span></div><div class="line"><span class="keyword">const</span> cSelector =  <span class="function">(<span class="params">_, props</span>) =&gt;</span> props.c</div><div class="line"></div><div class="line"><span class="comment">// state only (props argument omitted as not required)</span></div><div class="line"><span class="keyword">const</span> dSelector = <span class="function"><span class="params">state</span> =&gt;</span> state.d</div><div class="line"></div><div class="line"><span class="keyword">const</span> totalSelector = createSelector(</div><div class="line">  abSelector,</div><div class="line">  cSelector,</div><div class="line">  dSelector,</div><div class="line">  (ab, c, d) =&gt; (&#123;</div><div class="line">    <span class="attr">total</span>: ab + c + d</div><div class="line">  &#125;)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<hr>
<p>###defaultMemoize(func, equalityCheck = defaultEqualityCheck)</p>
<p><code>defaultMemoize</code>能记住通过func传递的参数.这是<code>createSelector</code>使用的记忆函数.</p>
<p><code>defaultMemoize</code> 通过调用<code>equalityCheck</code>函数来决定一个参数是否已经发生改变.因为<code>defaultMemoize</code>设计出来就是和immutable数据一起使用,默认的<code>equalityCheck</code>使用引用全等于来判断变化:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultEqualityCheck</span>(<span class="params">currentVal, previousVal</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> currentVal === previousVal</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><code>defaultMemoize</code>和<code>createSelectorCreator</code>去<a href="#配置-equalitycheck-for-defaultmemoize">配置<code>equalityCheck</code>函数</a>.</p>
<p>###createSelectorCreator(memoize,…memoizeOptions)</p>
<p><code>createSelectorCreator</code>用来配置定制版本的<code>createSelector</code>.</p>
<p><code>memoize</code>参数是一个有记忆功能的函数,来代替<code>defaultMemoize</code>.<br><code>…memoizeOption</code>展开的参数是0或者更多的配置选项,这些参数传递给<code>memoizeFunc</code>.selectors<code>resultFunc</code>作为第一个参数传递给<code>memoize</code>,<code>memoizeOptions</code>作为第二个参数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> customSelectorCreator = createSelectorCreator(</div><div class="line">  customMemoize, <span class="comment">// function to be used to memoize resultFunc,记忆resultFunc</span></div><div class="line">  option1, <span class="comment">// option1 will be passed as second argument to customMemoize 第二个惨呼</span></div><div class="line">  option2, <span class="comment">// option2 will be passed as third argument to customMemoize 第三个参数</span></div><div class="line">  option3 <span class="comment">// option3 will be passed as fourth argument to customMemoize   第四个参数</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> customSelector = customSelectorCreator(</div><div class="line">  input1,</div><div class="line">  input2,</div><div class="line">  resultFunc <span class="comment">// resultFunc will be passed as first argument to customMemoize  作为第一个参数传递给customMomize</span></div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>在<code>customSelecotr</code>内部滴啊用memoize的函数的代码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">customMemoize(resultFunc, option1, option2, option3)</div></pre></td></tr></table></figure></p>
<hr>
<p>下面是几个可能会用到的<code>createSelectorCreator</code>的实例:</p>
<p>####为<code>defaultMemoize</code>配置<code>equalityCheck</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelectorCreator, defaultMemoize &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"><span class="keyword">import</span> isEqual <span class="keyword">from</span> <span class="string">'lodash.isEqual'</span></div><div class="line"></div><div class="line"><span class="comment">// create a "selector creator" that uses lodash.isEqual instead of ===</span></div><div class="line"><span class="keyword">const</span> createDeepEqualSelector = createSelectorCreator(</div><div class="line">  defaultMemoize,</div><div class="line">  isEqual</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// use the new "selector creator" to create a selector</span></div><div class="line"><span class="keyword">const</span> mySelector = createDeepEqualSelector(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.values.filter(<span class="function"><span class="params">val</span> =&gt;</span> val &lt; <span class="number">5</span>),</div><div class="line">  values =&gt; values.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>####使用loadsh的memoize函数来缓存未绑定的缓存.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelectorCreator &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"><span class="keyword">import</span> memoize <span class="keyword">from</span> <span class="string">'lodash.memoize'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> called = <span class="number">0</span></div><div class="line"><span class="keyword">const</span> hashFn = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.reduce(</div><div class="line">  <span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + <span class="string">'-'</span> + <span class="built_in">JSON</span>.stringify(val),</div><div class="line">  <span class="string">''</span></div><div class="line">)</div><div class="line"><span class="keyword">const</span> customSelectorCreator = createSelectorCreator(memoize, hashFn)</div><div class="line"><span class="keyword">const</span> selector = customSelectorCreator(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.a,</div><div class="line">  state =&gt; state.b,</div><div class="line">  (a, b) =&gt; &#123;</div><div class="line">    called++</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<h3 id="createStructuredSelector-inputSelectors-selectorCreator-createSelector"><a href="#createStructuredSelector-inputSelectors-selectorCreator-createSelector" class="headerlink" title="createStructuredSelector({inputSelectors}, selectorCreator = createSelector)"></a>createStructuredSelector({inputSelectors}, selectorCreator = createSelector)</h3><p>如果在普通的模式下使用<code>createStructuredSelector</code>函数可以提升便利性.传递到<code>connect</code>的selector装饰者(这是js设计模式的概念,可以参考相关的书籍)接受他的input-selectors,并且在一个对象内映射到一个键上.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mySelectorA = <span class="function"><span class="params">state</span> =&gt;</span> state.a</div><div class="line"><span class="keyword">const</span> mySelectorB = <span class="function"><span class="params">state</span> =&gt;</span> state.b</div><div class="line"></div><div class="line"><span class="comment">// The result function in the following selector</span></div><div class="line"><span class="comment">// is simply building an object from the input selectors 由selectors构建的一个对象</span></div><div class="line"><span class="keyword">const</span> structuredSelector = createSelector(</div><div class="line">   mySelectorA,</div><div class="line">   mySelectorB,</div><div class="line">   mySelectorC,</div><div class="line">   (a, b, c) =&gt; (&#123;</div><div class="line">     a,</div><div class="line">     b,</div><div class="line">     c</div><div class="line">   &#125;)</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p><code>createStructuredSelector</code>接受一个对象,这个对象的属性是input-selectors,函数返回一个结构性的selector.这个结构性的selector返回一个对象,对象的键和<code>inputSelectors</code>的参数是相同的,但是使用selectors代替了其中的值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mySelectorA = <span class="function"><span class="params">state</span> =&gt;</span> state.a</div><div class="line"><span class="keyword">const</span> mySelectorB = <span class="function"><span class="params">state</span> =&gt;</span> state.b</div><div class="line"></div><div class="line"><span class="keyword">const</span> structuredSelector = createStructuredSelector(&#123;</div><div class="line">  <span class="attr">x</span>: mySelectorA,</div><div class="line">  <span class="attr">y</span>: mySelectorB</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">const</span> result = structuredSelector(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;) <span class="comment">// will produce &#123; x: 1, y: 2 &#125;</span></div></pre></td></tr></table></figure>
<hr>
<p>结构性的selectors可以是嵌套式的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> nestedSelector = createStructuredSelector(&#123;</div><div class="line">  <span class="attr">subA</span>: createStructuredSelector(&#123;</div><div class="line">    selectorA,</div><div class="line">    selectorB</div><div class="line">  &#125;),</div><div class="line">  <span class="attr">subB</span>: createStructuredSelector(&#123;</div><div class="line">    selectorC,</div><div class="line">    selectorD</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<p>##FAQ</p>
<h3 id="Q-为什么当输入的state发生改变的时候-selector不重新计算？"><a href="#Q-为什么当输入的state发生改变的时候-selector不重新计算？" class="headerlink" title="Q:为什么当输入的state发生改变的时候,selector不重新计算？"></a>Q:为什么当输入的state发生改变的时候,selector不重新计算？</h3><p>A:检查一下你的记忆韩式是不是和你的state更新函数相兼容(例如:如果你正在使用Redux).例如:使用<code>createSelector</code>创建的selector总是创建一个新的对象,原来期待的是更新一个已经存在的对象.<code>createSelector</code>使用(===)检测输入是否改变,因此如果改变一个已经存在的对象没有触发selector重新计算的原因是改变一个对象的时候没有触发相关的检测.提示：如果你正在使用Redux,改变一个state对象的<a href="http://redux.js.org/docs/Troubleshooting.html" target="_blank" rel="external">错误可能有</a>.</p>
<p>下面的实例定义了一个selector可以决定数组的第一个todo项目是不是已经被完成:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isFirstTodoCompleteSelector = createSelector(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.todos[<span class="number">0</span>],</div><div class="line">  todo =&gt; todo &amp;&amp; todo.completed</div><div class="line">)</div></pre></td></tr></table></figure></p>
<hr>
<p>下面的state更新函数和<code>isFirstTodoCompleteSelector</code><strong>将不会</strong>正常工作工作:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">  <span class="keyword">case</span> COMPLETE_ALL:</div><div class="line">    <span class="keyword">const</span> areAllMarked = state.every(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed)</div><div class="line">    <span class="comment">// BAD: mutating an existing object</span></div><div class="line">    <span class="keyword">return</span> state.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</div><div class="line">      todo.completed = !areAllMarked</div><div class="line">      <span class="keyword">return</span> todo</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>下面的state更新函数和<code>isFirstTodoComplete</code>一起<strong>可以</strong>正常工作.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">  <span class="keyword">case</span> COMPLETE_ALL:</div><div class="line">    <span class="keyword">const</span> areAllMarked = state.every(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed)</div><div class="line">    <span class="comment">// GOOD: returning a new object each time with Object.assign</span></div><div class="line">    <span class="keyword">return</span> state.map(<span class="function"><span class="params">todo</span> =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</div><div class="line">      <span class="attr">completed</span>: !areAllMarked</div><div class="line">    &#125;))</div><div class="line"></div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>如果你没有使用Redux,但是有使用mutable数据的需求,你可以使用<code>createSelectorCreator</code>代替默认的记忆函数,并且使用不同的等值检测函数.请参看<a href="#use-memoize-function-from-lodash-for-an-unbounded-cache">这里</a> 和 <a href="#customize-equalitycheck-for-defaultmemoize">这里</a>作为参考.</p>
<p>###Q:为什么input state没有改变的时候,selector还是会重新计算?</p>
<p>A: 检查一下你的记忆函数和你你的state更新函数是不是兼容(如果是使用Redux的时候,看看reducer).例如:使用每一次更新的时候,不管值是不是发生改变,<code>createSelector</code>创建的selector总是会收到一个新的对象.<code>createSelector</code>函数使用(<code>===</code>)检测input的变化,由此可知如果每次都返回一个新对象,表示selector总是在每次更新的时候重新计算.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; REMOVE_OLD &#125; <span class="keyword">from</span> <span class="string">'../constants/ActionTypes'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> initialState = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">text</span>: <span class="string">'Use Redux'</span>,</div><div class="line">    <span class="attr">completed</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">id</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">timestamp</span>: <span class="built_in">Date</span>.now()</div><div class="line">  &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">  <span class="keyword">case</span> REMOVE_OLD:</div><div class="line">    <span class="keyword">return</span> state.filter(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> todo.timestamp + <span class="number">30</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> &gt; <span class="built_in">Date</span>.now()</div><div class="line">    &#125;)</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>下面的selector在每一次REMOVE_OLD调用的时候,都会重新计算,因为Array.filter总是返回一个新对象.但是在大多数情况下,REMOVE_OLD action都不会改变todo列表,所以重新计算是不必要的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> todosSelector = <span class="function"><span class="params">state</span> =&gt;</span> state.todos</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> visibleTodosSelector = createSelector(</div><div class="line">  todosSelector,</div><div class="line">  (todos) =&gt; &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>你可以通过state更新函数返回一个新对象来减少不必要的重计算操作,这个对象执行深度等值检测,只有深度不相同的时候才返回新对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; REMOVE_OLD &#125; <span class="keyword">from</span> <span class="string">'../constants/ActionTypes'</span></div><div class="line"><span class="keyword">import</span> isEqual <span class="keyword">from</span> <span class="string">'lodash.isEqual'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> initialState = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">text</span>: <span class="string">'Use Redux'</span>,</div><div class="line">    <span class="attr">completed</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">id</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">timestamp</span>: <span class="built_in">Date</span>.now()</div><div class="line">  &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">  <span class="keyword">case</span> REMOVE_OLD:</div><div class="line">    <span class="keyword">const</span> updatedState =  state.filter(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> todo.timestamp + <span class="number">30</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> &gt; <span class="built_in">Date</span>.now()</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> isEqual(updatedState, state) ? state : updatedState</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>替代的方法是,在selector中使用深度检测方法替代默认的<code>equalityCheck</code>函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelectorCreator, defaultMemoize &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"><span class="keyword">import</span> isEqual <span class="keyword">from</span> <span class="string">'lodash.isEqual'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> todosSelector = <span class="function"><span class="params">state</span> =&gt;</span> state.todos</div><div class="line"></div><div class="line"><span class="comment">// create a "selector creator" that uses lodash.isEqual instead of ===</span></div><div class="line"><span class="keyword">const</span> createDeepEqualSelector = createSelectorCreator(</div><div class="line">  defaultMemoize,</div><div class="line">  isEqual</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// use the new "selector creator" to create a selector</span></div><div class="line"><span class="keyword">const</span> mySelector = createDeepEqualSelector(</div><div class="line">  todosSelector,</div><div class="line">  (todos) =&gt; &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>检查<code>equalityCheck</code>函数的更替或者在state更新函数中做深度检测并不总是比重计算的花销小.如果每次重计算的花销总是比较小,可能的原因是Reselect没有通过<code>connect</code>函数传递<code>mapStateProps</code>单纯对象的原因.</p>
<h3 id="Q-没有Redux的情况下可以使用Reselect吗？"><a href="#Q-没有Redux的情况下可以使用Reselect吗？" class="headerlink" title="Q:没有Redux的情况下可以使用Reselect吗？"></a>Q:没有Redux的情况下可以使用Reselect吗？</h3><p>A:可以.Reselect没有其他任何的依赖包,因此尽管他设计的和Redux比较搭配,但是独立使用也是可以的.目前的版本在传统的Flux APP下使用是比较成功的.</p>
<blockquote>
<p>如果你使用<code>createSelector</code>创建的selectors,需要确保他的参数是immutable的.</p>
<p>看<a href="#createselectorinputselectors--inputselectors-resultfunc">这里</a></p>
</blockquote>
<h3 id="Q-怎么才能创建一个接收参数的selector"><a href="#Q-怎么才能创建一个接收参数的selector" class="headerlink" title="Q:怎么才能创建一个接收参数的selector."></a>Q:怎么才能创建一个接收参数的selector.</h3><p>A:Reselect没有支持创建接收参数的selectors,但是这里有一些实现类似函数功能的建议.</p>
<p>如果参数不是动态的,你可以使用工厂函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> expensiveItemSelectorFactory = <span class="function"><span class="params">minValue</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> createSelector(</div><div class="line">    shopItemsSelector,</div><div class="line">    items =&gt; items.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.value &gt; minValue)</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> subtotalSelector = createSelector(</div><div class="line">  expensiveItemSelectorFactory(<span class="number">200</span>),</div><div class="line">  items =&gt; items.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc + item.value, <span class="number">0</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>总的达成共识<a href="https://github.com/reactjs/reselect/issues/38" target="_blank" rel="external">看这里</a>和<a href="https://github.com/optimizely/nuclear-js/issues/14" target="_blank" rel="external">超越 neclear-js</a>是:如果一个selector需要动态的参数,那么参数应该是store中的state.如果你决定好了在应用中使用动态参数,像下面这样返回一个记忆函数是比较合适的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"><span class="keyword">import</span> memoize <span class="keyword">from</span> <span class="string">'lodash.memoize'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> expensiveSelector = createSelector(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.items,</div><div class="line">  items =&gt; memoize(</div><div class="line">    <span class="function"><span class="params">minValue</span> =&gt;</span> items.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.value &gt; minValue)</div><div class="line">  )</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> expensiveFilter = expensiveSelector(state)</div><div class="line"></div><div class="line"><span class="keyword">const</span> slightlyExpensive = expensiveFilter(<span class="number">100</span>)</div><div class="line"><span class="keyword">const</span> veryExpensive = expensiveFilter(<span class="number">1000000</span>)</div></pre></td></tr></table></figure>
<hr>
<h3 id="Q：默认的记忆函数不太好-我能用个其他的吗？"><a href="#Q：默认的记忆函数不太好-我能用个其他的吗？" class="headerlink" title="Q：默认的记忆函数不太好,我能用个其他的吗？"></a>Q：默认的记忆函数不太好,我能用个其他的吗？</h3><p>A: 我认为这个记忆韩式工作的还可以,但是如果你需要一个其他的韩式也是可以的.<br>可以看看这个<a href="#customize-equalitycheck-for-defaultmemoize">例子</a></p>
<h3 id="Q-怎么才能测试一个selector"><a href="#Q-怎么才能测试一个selector" class="headerlink" title="Q:怎么才能测试一个selector?"></a>Q:怎么才能测试一个selector?</h3><p>A:对于一个给定的input,一个selector总是产出相同的结果.基于这个原因,做单元测试是非常简单的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> selector = createSelector(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> state.a,</div><div class="line">  state =&gt; state.b,</div><div class="line">  (a, b) =&gt; (&#123;</div><div class="line">    <span class="attr">c</span>: a * <span class="number">2</span>,</div><div class="line">    <span class="attr">d</span>: b * <span class="number">3</span></div><div class="line">  &#125;)</div><div class="line">)</div><div class="line"></div><div class="line">test(<span class="string">"selector unit test"</span>, () =&gt; &#123;</div><div class="line">  assert.deepEqual(selector(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;), &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">6</span> &#125;)</div><div class="line">  assert.deepEqual(selector(&#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;), &#123; <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: <span class="number">9</span> &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<p>在state更新函数调用的时候同时检测selector的记忆函数的功能也是非常有用的(例如 使用Redux的时候检查reducer).每一个selector都有一个<code>recomputations</code>方法返回重新计算的次数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">suite(<span class="string">'selector'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> state = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> (</div><div class="line">    &#123;</div><div class="line">      <span class="attr">a</span>: action(state.a),</div><div class="line">      <span class="attr">b</span>: action(state.b)</div><div class="line">    &#125;</div><div class="line">  )</div><div class="line"></div><div class="line">  <span class="keyword">const</span> selector = createSelector(</div><div class="line">    <span class="function"><span class="params">state</span> =&gt;</span> state.a,</div><div class="line">    state =&gt; state.b,</div><div class="line">    (a, b) =&gt; (&#123;</div><div class="line">      <span class="attr">c</span>: a * <span class="number">2</span>,</div><div class="line">      <span class="attr">d</span>: b * <span class="number">3</span></div><div class="line">    &#125;)</div><div class="line">  )</div><div class="line"></div><div class="line">  <span class="keyword">const</span> plusOne = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span></div><div class="line">  <span class="keyword">const</span> id = <span class="function"><span class="params">x</span> =&gt;</span> x</div><div class="line"></div><div class="line">  test(<span class="string">"selector unit test"</span>, () =&gt; &#123;</div><div class="line">    state = reducer(state, plusOne)</div><div class="line">    assert.deepEqual(selector(state), &#123; <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: <span class="number">9</span> &#125;)</div><div class="line">    state = reducer(state, id)</div><div class="line">    assert.deepEqual(selector(state), &#123; <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: <span class="number">9</span> &#125;)</div><div class="line">    assert.equal(selector.recomputations(), <span class="number">1</span>)</div><div class="line">    state = reducer(state, plusOne)</div><div class="line">    assert.deepEqual(selector(state), &#123; <span class="attr">c</span>: <span class="number">6</span>, <span class="attr">d</span>: <span class="number">12</span> &#125;)</div><div class="line">    assert.equal(selector.recomputations(), <span class="number">2</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<hr>
<p>另外,selectors保留了最后一个函数调用结果的引用,这个引用作为<code>.resultFunc</code>.如果你已经聚合了其他的selectors,这个函数引用可以帮助你测试每一个selector,不需要从state中解耦测试.</p>
<p>例如如果你的selectors集合像下面这样:<br><strong>selectors.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> firstSelector = createSelector( ... )</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> secondSelector = createSelector( ... )</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> thirdSelector = createSelector( ... )</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> myComposedSelector = createSelector(</div><div class="line">  firstSelector,</div><div class="line">  secondSelector,</div><div class="line">  thirdSelector,</div><div class="line">  (first, second, third) =&gt; first * second &lt; third</div><div class="line">)</div></pre></td></tr></table></figure></p>
<hr>
<p>单元测试就像下面这样:<br><strong>test/selectors.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tests for the first three selectors...</span></div><div class="line">test(<span class="string">"firstSelector unit test"</span>, () =&gt; &#123; ... &#125;)</div><div class="line">test(<span class="string">"secondSelector unit test"</span>, () =&gt; &#123; ... &#125;)</div><div class="line">test(<span class="string">"thirdSelector unit test"</span>, () =&gt; &#123; ... &#125;)</div><div class="line"></div><div class="line"><span class="comment">// We have already tested the previous</span></div><div class="line"><span class="comment">// three selector outputs so we can just call `.resultFunc`</span></div><div class="line"><span class="comment">// with the values we want to test directly:</span></div><div class="line">test(<span class="string">"myComposedSelector unit test"</span>, () =&gt; &#123;</div><div class="line">  <span class="comment">// here instead of calling selector()</span></div><div class="line">  <span class="comment">// we just call selector.resultFunc()</span></div><div class="line">  assert(selector.resultFunc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="literal">true</span>)</div><div class="line">  assert(selector.resultFunc(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>), <span class="literal">false</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<p>最后,每一个selector有一个<code>resetRecomputations</code>方法,重置recomputations方法为0,这个参数的意图是在面对复杂的selector的时候,需要很多独立的测试,你不需要管理复杂的手工计算,或者为每一个测试创建”傻瓜”selector.</p>
<h3 id="Q-Reselect怎么和Immutble-js一起使用"><a href="#Q-Reselect怎么和Immutble-js一起使用" class="headerlink" title="Q:Reselect怎么和Immutble.js一起使用?"></a>Q:Reselect怎么和Immutble.js一起使用?</h3><p>A:<code>creatSelector</code>创建的Selectors应该可以和Immutable.js数据结构一起完美的工作.<br>如果你的selector正在重计算,并且你认为state没有发生变化,一定要确保知道哪一个Immutable.js更新方法,这个方法只要一更新<strong>总是</strong>返回新对象.哪一个方法只有<strong>集合实际发生变化的时候</strong>才返回新对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Immutable <span class="keyword">from</span> <span class="string">'immutable'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> myMap = Immutable.Map(&#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">c</span>: <span class="number">3</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"> <span class="comment">// set, merge and others only return a new obj when update changes collection</span></div><div class="line"><span class="keyword">let</span> newMap = myMap.set(<span class="string">'a'</span>, <span class="number">1</span>)</div><div class="line">assert.equal(myMap, newMap)</div><div class="line">newMap = myMap.merge(&#123; <span class="string">'a'</span>, <span class="number">1</span> &#125;)</div><div class="line">assert.equal(myMap, newMap)</div><div class="line"><span class="comment">// map, reduce, filter and others always return a new obj</span></div><div class="line">newMap = myMap.map(<span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">1</span>)</div><div class="line">assert.notEqual(myMap, newMap)</div></pre></td></tr></table></figure>
<hr>
<p>如果一个操作导致的selector更新总是返回一个新对象,可能会发生不必要的重计算.<a href="#q-why-is-my-selector-recomputing-when-the-input-state-stays-the-same">看这里</a>.这是一个关于pros的讨论,使用深全等于来检测例如<code>immutable.js</code>来减少不必要的重计算过程.</p>
<h3 id="Q-可以在多个组件之间共享selector吗？"><a href="#Q-可以在多个组件之间共享selector吗？" class="headerlink" title="Q:可以在多个组件之间共享selector吗？"></a>Q:可以在多个组件之间共享selector吗？</h3><p>A: 使用<code>createSelector</code>创建的Selector的缓存的大小只有1.这个设定使得多个组件的实例之间的参数不同,跨组件共享selector变得不合适.这里也有几种办法来解决这个问题:</p>
<ul>
<li>使用工程函数方法,为每一个组件实例创建一个新的selector.这里有一个内建的工厂方法,React Redux v4.3或者更高版本可以使用. <a href="#sharing-selectors-with-props-across-multiple-components">看这里</a></li>
<li>创建一个缓存尺寸大于1的定制selector.</li>
</ul>
<h3 id="Q-有TypeScript的类型吗？"><a href="#Q-有TypeScript的类型吗？" class="headerlink" title="Q:有TypeScript的类型吗？"></a>Q:有TypeScript的类型吗？</h3><p>A: 是的！他们包含在<code>package.json</code>里.可以很好的工作.</p>
<h3 id="Q：怎么构建一个柯里化selector"><a href="#Q：怎么构建一个柯里化selector" class="headerlink" title="Q：怎么构建一个柯里化selector?"></a>Q：怎么构建一个<a href="https://github.com/hemanth/functional-programming-jargon#currying" target="_blank" rel="external">柯里化</a>selector?</h3><p>A：尝试一些这里<a href="https://github.com/reactjs/reselect/issues/159#issuecomment-238724788" target="_blank" rel="external">助手函数</a>,由<a href="https://github.com/MattSPalmer" target="_blank" rel="external">MattSPalmer</a>提供</p>
<h2 id="有关的项目"><a href="#有关的项目" class="headerlink" title="有关的项目"></a>有关的项目</h2><h3 id="reselect-map"><a href="#reselect-map" class="headerlink" title="reselect-map"></a><a href="https://github.com/HeyImAlex/reselect-map" target="_blank" rel="external">reselect-map</a></h3><p>因为Reselect不可能保证缓存你所有的需求,在做<strong>非常昂贵的计算</strong>的时候,这个方法比较有用.查看一下reselect-maps readme</p>
<p><strong>reselect-map的优化措施仅仅使用在一些小的案例中,如果你不确定是不是需要他,就不要使用它</strong>.</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文是翻译Redux的一个中间件文档.Redux是React的一个数据层,React组件的state有关逻辑处理都被单独放到Redux中来进行,在state的操作流程中衍生了很多中间件,Reselect这个中间件要解决的问题是:`在
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript设计原则-单一职责</title>
    <link href="http://yoursite.com/2017/03/09/javascript%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3/"/>
    <id>http://yoursite.com/2017/03/09/javascript设计原则-单一职责/</id>
    <published>2017-03-08T20:04:10.000Z</published>
    <updated>2017-03-23T12:14:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面把javascript的设计模式基本过了一遍，可以说是感慨很多，许多的思想都是从未接触过的，学起来难度也不小，但是我觉得这个过程是很值得的。如果以前是在足球场上踢野球的话，现在总算找到一个像模像样的教练在指导了，不一定会成为一个世界级的球星，但是水平至少也会比以前提高很多。<br>接下来会看看一些设计原则，设计原则是比模式更高一级的方法，是纲领性的内容。</p>
<blockquote>
<p>单一职责(single responsable princple)被定为为“引起变化的原因”。如果一个方法承担了过多的职责，那么在需求发生变化的过程中，需要改写这个方法的可能性就越大。<br>因此SRP原则体现为：一个对象(方法)只做一件事情。<br>参考《javascript设计模式与开发实践》第18章</p>
</blockquote>
<p>#####设计模式中的SRP原则</p>
<p>代理模式<br>下面这个例子是要在文档中创建一个img标签，并且要插入图片<br>在加载图片的时候，由于网速的限制需要预先加载一张本地图片，稍后会加载网络图片。 在这个过程中<code>创建img标签</code>和<code>更换图片源</code>是<code>没有关系</code>的。所以最好是把这两个过程分为两个对象来处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建img标签的对象</span></div><div class="line"><span class="keyword">var</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement( <span class="string">'img'</span> );</div><div class="line">		<span class="built_in">document</span>.body.appendChild( imgNode );</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			<span class="attr">setSrc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;</div><div class="line"></div><div class="line">				imgNode.src = src;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;)();</div><div class="line">  <span class="comment">//添加图片路径的对象</span></div><div class="line">	<span class="keyword">var</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> img = <span class="keyword">new</span> Image; <span class="comment">//实例化标签对象</span></div><div class="line">		img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			myImage.setSrc( <span class="keyword">this</span>.src ); <span class="comment">//加载默认图片</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			<span class="attr">setSrc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;</div><div class="line">				myImage.setSrc( <span class="string">'file:// /C:/Users/svenzeng/Desktop/loading.gif'</span> );</div><div class="line">				img.src = src;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;)();</div><div class="line">	<span class="comment">//更改图片的路径，这个过程就和img标签的创建对象没有关系了。</span></div><div class="line">	proxyImage.setSrc( <span class="string">'http:// imgcache.qq.com/music/photo/000GGDys0yA0Nk.jpg'</span> );</div></pre></td></tr></table></figure></p>
<p>迭代器模式<br>看下面段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这段代码往文档中添加div元素，但是有限制，这里就只能添加数组</span></div><div class="line"><span class="comment">//有两个职责一个是添加元素，一个是遍历数据，所有有必要分开</span></div><div class="line"> <span class="keyword">var</span> appendDiv=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;l=data.length;i&lt;l;i++)&#123;</div><div class="line">   <span class="keyword">var</span> div=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">   div.innerHTML=data[i];</div><div class="line">   <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">  &#125;</div><div class="line"> &#125;;</div><div class="line"> </div><div class="line"> appenDiv([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div></pre></td></tr></table></figure></p>
<p>使用单一职责原则改变代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> each = <span class="function"><span class="keyword">function</span>(<span class="params"> obj, callback </span>) </span>&#123;<span class="comment">//遍历的方法</span></div><div class="line"><span class="comment">//对象和数组都可以输入，灵活性加大，并且还可以修改</span></div><div class="line">		<span class="keyword">var</span> value,</div><div class="line">		i = <span class="number">0</span>,</div><div class="line">		length = obj.length,</div><div class="line">		isArray = isArraylike( obj ); <span class="comment">// isArraylike 函数未实现，可以翻阅jQuery 源代码</span></div><div class="line">		<span class="keyword">if</span> ( isArray ) &#123; <span class="comment">// 迭代类数组</span></div><div class="line">			<span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</div><div class="line">				callback.call( obj[ i ], i, obj[ i ] );</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">for</span> ( i <span class="keyword">in</span> obj ) &#123; <span class="comment">// 迭代object 对象</span></div><div class="line">				value = callback.call( obj[ i ], i, obj[ i ] );</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> obj;</div><div class="line">	&#125;;</div><div class="line"> <span class="comment">//根据输入数据的元素添加方法</span></div><div class="line">	<span class="keyword">var</span> appendDiv = <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123;</div><div class="line">		each( data, <span class="function"><span class="keyword">function</span>(<span class="params"> i, n </span>)</span>&#123; <span class="comment">//使用each方法来执行遍历</span></div><div class="line">		<span class="comment">//在回调函数中根据遍历数据添加元素至文档中</span></div><div class="line">			<span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</div><div class="line">			div.innerHTML = n;</div><div class="line">			<span class="built_in">document</span>.body.appendChild( div );</div><div class="line">		&#125;);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	appendDiv( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ] );<span class="comment">//数组数据</span></div><div class="line">	appendDiv(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>,<span class="attr">d</span>:<span class="number">4</span>&#125; ); <span class="comment">//对象数据</span></div></pre></td></tr></table></figure></p>
<p>单例模式</p>
<p>在前面已经有笔记了。实际是把实际操作和创建单例的方法分别封装在两个方法里。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> createLoginLayer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//创建元素的方法</span></div><div class="line">		<span class="keyword">var</span> div;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">if</span> ( !div )&#123;</div><div class="line">				div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</div><div class="line">				div.innerHTML = <span class="string">'我是登录浮窗'</span>;</div><div class="line">				div.style.display = <span class="string">'none'</span>;</div><div class="line">				<span class="built_in">document</span>.body.appendChild( div );</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> div; <span class="comment">//单例的判断依据</span></div><div class="line">		&#125;</div><div class="line">	&#125;)();</div><div class="line">  </div><div class="line">        <span class="comment">//创建和检测单例的方法，参数为创建元素的方法</span></div><div class="line">	<span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123; <span class="comment">// 获取单例</span></div><div class="line">		<span class="keyword">var</span> result;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> result || ( result = fn .apply(<span class="keyword">this</span>, <span class="built_in">arguments</span> ) ); </div><div class="line">                        <span class="comment">//这个地方要注意apply和arguments的应用</span></div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 创建登录浮窗</span></div><div class="line">		<span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</div><div class="line">		div.innerHTML = <span class="string">'我是登录浮窗'</span>;</div><div class="line">		<span class="built_in">document</span>.body.appendChild( div );</div><div class="line">		<span class="keyword">return</span> div;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	<span class="keyword">var</span> createSingleLoginLayer = getSingle( createLoginLayer );</div><div class="line">	<span class="keyword">var</span> loginLayer1 = createSingleLoginLayer();</div><div class="line">	<span class="keyword">var</span> loginLayer2 = createSingleLoginLayer();</div><div class="line">	alert ( loginLayer1 === loginLayer2 ); <span class="comment">// 输出： true  //为同一对象</span></div></pre></td></tr></table></figure></p>
<p>装饰者模式<br>前面的设计模式里也有介绍<br>装饰者模式可以动态为对象添加方法或指责。从而也使的对象的功能单一化。<br>下面两个函数调用的时候指向同一个对象。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params"> afterfn </span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> __self = <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">var</span> ret = __self.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">			 <span class="comment">//执行原函数</span></div><div class="line">			afterfn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );<span class="comment">//执行after函数</span></div><div class="line">			<span class="keyword">return</span> ret;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="string">'打开登录浮层'</span> );</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="string">'上报标签为: '</span> + <span class="keyword">this</span>.getAttribute( <span class="string">'tag'</span> ) );</div><div class="line"></div><div class="line">	&#125;;</div><div class="line">	<span class="built_in">document</span>.getElementById( <span class="string">'button'</span> ).onclick = showLogin.after( log );</div><div class="line"><span class="comment">// 打开登录浮层之后上报数据</span></div></pre></td></tr></table></figure></p>
<p>#####单一职责原则减低了单个类或者对象的复杂度，按照指责把对象分解成更小的粒度。有助于代码的复用，修改和测试。但是代码复杂度是提高了。怎么平衡呢？这是个问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面把javascript的设计模式基本过了一遍，可以说是感慨很多，许多的思想都是从未接触过的，学起来难度也不小，但是我觉得这个过程是很值得的。如果以前是在足球场上踢野球的话，现在总算找到一个像模像样的教练在指导了，不一定会成为一个世界级的球星，但是水平至少也会比以前提高很
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript最少知识原则</title>
    <link href="http://yoursite.com/2017/03/09/javascript%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2017/03/09/javascript最少知识原则/</id>
    <published>2017-03-08T19:04:10.000Z</published>
    <updated>2017-03-23T12:19:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最少知识原则说的是一个软件实体应当尽可能的与其他实体减少相互作用。<br>这里的软件实体是一个广义概念，不仅包括对象，还包括系统，类，模块，函数，变量灯。这样来说最少知识原则涵盖的范围就很大了。下面看看和javascript相关的内容<br>参考《javascirpt模式设计与开发实践》第19章</p>
</blockquote>
<ol>
<li><p>减少对象之间的联系<br>最少知识原则指导我们，如果两个对象之间不必彼此通讯，那么这两个对象之间就不要发生直接联系。常见的做法是引入一个第三者来承担彼此的通信任务。</p>
</li>
<li><p>javascript设计模式中的最少知识原则</p>
</li>
</ol>
<p><strong>中介者模式</strong><br>这个模式是使用者们是不发生任何联系的，所有的信息都是由中介者来完成。<br>react通过引入redux应该就是这种模式。react组件之间不再发生任何的联系，所有与组件state变化的通讯请求都是通过redux来完成的。这样一来，组件可以应对复杂的state变化。</p>
<p><strong>外观模式</strong><br>这是针对使用者而言的。外观模式作用是对交互使用者隐藏子系统的复杂性。</p>
<ul>
<li>[ ] 外观模式为一组系统提供一个便利的入口。在jquery中兼容了浏览器的差异，但是使用者使用的是同一个api接口，就是一个体现</li>
<li>[ ] 隔离使用者和复杂系统的联系，使用者不需要去了解具体的差异</li>
</ul>
<p>javascript的函数封装</p>
<p>javascript函数有着至高无上的权利，灵活性很大。通过使用闭包隐藏变量，通过单例模式，揭示模式，策略模式.javascript使用函数和对象字面量的方法隐藏具体的实现逻辑。只暴露相关的方法。</p>
<p>这就是最少知识原则。这也是基础原则在javascript程序设计中应该是时刻都要体现这种原则。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最少知识原则说的是一个软件实体应当尽可能的与其他实体减少相互作用。&lt;br&gt;这里的软件实体是一个广义概念，不仅包括对象，还包括系统，类，模块，函数，变量灯。这样来说最少知识原则涵盖的范围就很大了。下面看看和javascript相关的内容&lt;br&gt;参考《
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript设计模式-单例模式</title>
    <link href="http://yoursite.com/2017/03/08/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/03/08/javascript设计模式-单例模式/</id>
    <published>2017-03-08T11:04:10.000Z</published>
    <updated>2017-03-23T12:28:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>单例模式的定义：保证一个类仅有一个实例，并提供一个访问他的全局访问点<br>参考书籍《javascript设计模式与开发实践》<br>有一些对象我们只需要一个，例如线程池，全局缓存等。</p>
</blockquote>
<ol>
<li>实例单例模式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.instance = <span class="literal">null</span>;</div><div class="line">	&#125;;</div><div class="line">	Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert ( <span class="keyword">this</span>.name );</div><div class="line">	&#125;;</div><div class="line">	Singleton.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span> ( !<span class="keyword">this</span>.instance )&#123;  <span class="comment">//对实例进行检测</span></div><div class="line">			<span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton( name ); <span class="comment">//全局缓存new 对象</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.instance;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> a = Singleton.getInstance( <span class="string">'sven1'</span> );  <span class="comment">//第一次实例化，检测没有实例化的对象，自己实例化一个，然后缓存</span></div><div class="line">	<span class="keyword">var</span> b = Singleton.getInstance( <span class="string">'sven2'</span> );<span class="comment">//第二次实例化，检测已经有全局的实例化的对象，直接返回，不进行具体实例化</span></div><div class="line">	alert ( a === b ); <span class="comment">// true    //统一实例对象</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;单例模式的定义：保证一个类仅有一个实例，并提供一个访问他的全局访问点&lt;br&gt;参考书籍《javascript设计模式与开发实践》&lt;br&gt;有一些对象我们只需要一个，例如线程池，全局缓存等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;实例单例
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript桥接模式(1)-队列数据结构</title>
    <link href="http://yoursite.com/2017/03/08/javascript%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F(1)-%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2017/03/08/javascript桥接模式(1)-队列数据结构/</id>
    <published>2017-03-08T11:04:10.000Z</published>
    <updated>2017-03-23T12:11:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>根据书上例子的实际要求，涉及到js队列的问题。所以先把js中队列的具体实现数据结构贴出来。具体参考《学习javascript数据结构和算法》第四章。<br>队列数据结构遵循先入先出的原则。入队操作添加到数组的末尾，返回新数组。出队操作弹出数组第一个元素，返回新数组。两个操作对于数组都有结构的改变</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//js中队列的实现是依赖数组的数据结构</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> items = [];  <span class="comment">//初始化空数组，let关键字是es6中的</span></div><div class="line">    <span class="comment">//用于形成大括号包围的作用域</span></div><div class="line"></div><div class="line">    <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123; <span class="comment">//入队操作</span></div><div class="line">        items.push(element); <span class="comment">//数组push操作</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//出对</span></div><div class="line">        <span class="keyword">return</span> items.shift(); <span class="comment">//数组shift操作</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//队列第一个元素</span></div><div class="line">        <span class="keyword">return</span> items[<span class="number">0</span>];     <span class="comment">//数组第一个元素</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//判断队列有无成员</span></div><div class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>; <span class="comment">//布尔值判断</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//清空队列</span></div><div class="line">        items = [];   <span class="comment">//变量重新赋值空数组</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//获得队列的长度</span></div><div class="line">        <span class="keyword">return</span> items.length; </div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//打印队列</span></div><div class="line">        <span class="built_in">console</span>.log(items.toString());</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>下面是优先队列。数据成员入队的时候要携带数据和优先级。<br>优先级在这里的定义是数字越大在数组中的位置靠后。当插入一个数组元素的时候，先要根据它的优先级来判断，最小是直接插入到第一位，紧邻一个比他大的优先级是，就插入到这个邻居的前面。如果是最大的数字就插到数组的最后。<br>一维数组变成了二位数组。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PriorityQueue</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> items = [];</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">QueueElement</span> (<span class="params">element, priority</span>)</span>&#123; </div><div class="line">            <span class="keyword">this</span>.element = element;<span class="comment">//成员本身</span></div><div class="line">        <span class="keyword">this</span>.priority = priority;  <span class="comment">//优先级</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element, priority</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> queueElement = <span class="keyword">new</span> QueueElement(element, priority);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> added = <span class="literal">false</span>; <span class="comment">//添加标记</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;items.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span> (queueElement.priority &lt;            </div><div class="line"> items[i].priority)&#123;  <span class="comment">//找到优先级数字比他大的那个元素</span></div><div class="line"></div><div class="line">                items.splice(i,<span class="number">0</span>,queueElement);            </div><div class="line">             <span class="comment">// 插到这个元素的前面</span></div><div class="line">                added = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">break</span>; <span class="comment">// 终止</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!added)&#123; <span class="comment">//如果是优先级数字是最大的，直接插入到</span></div><div class="line">        <span class="comment">//数组的末尾</span></div><div class="line">            items.push(queueElement); <span class="comment">//&#123;5&#125;</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">//其他操作和普通队列是一样的</span></div><div class="line"></div><div class="line">    <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.shift();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items[<span class="number">0</span>];</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//print使用了es6里的拼接字符串的方法</span></div><div class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;items.length; i++)&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;items[i].element&#125;</span>  - <span class="subst">$&#123;items[i].priority&#125;</span>`</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> priorityQueue = <span class="keyword">new</span> PriorityQueue();</div><div class="line">priorityQueue.enqueue(<span class="string">"John"</span>, <span class="number">2</span>);</div><div class="line">priorityQueue.enqueue(<span class="string">"Jack"</span>, <span class="number">1</span>);</div><div class="line">priorityQueue.enqueue(<span class="string">"Camila"</span>, <span class="number">1</span>);</div><div class="line">priorityQueue.enqueue(<span class="string">"Maxwell"</span>, <span class="number">2</span>);</div><div class="line">priorityQueue.enqueue(<span class="string">"Ana"</span>, <span class="number">3</span>);</div><div class="line">priorityQueue.print();</div><div class="line"><span class="comment">//=&gt;</span></div><div class="line"><span class="comment">//打印出的结果</span></div><div class="line">Jack  - <span class="number">1</span>  <span class="comment">//数组元素--优先级</span></div><div class="line">Camila  - <span class="number">1</span></div><div class="line">John  - <span class="number">2</span></div><div class="line">Maxwell  - <span class="number">2</span></div><div class="line">Ana  - <span class="number">3</span></div></pre></td></tr></table></figure>
<p>在这个队列的基础上可以实现javascript中桥接模式的例子。本文算是一个独立的javascript队列的介绍，也作为桥接模式例子的背景方法。<br><a href="http://www.apress.com/cn/book/9781590599082" target="_blank" rel="external">javascript设计模式 第八章-桥接模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;根据书上例子的实际要求，涉及到js队列的问题。所以先把js中队列的具体实现数据结构贴出来。具体参考《学习javascript数据结构和算法》第四章。&lt;br&gt;队列数据结构遵循先入先出的原则。入队操作添加到数组的末尾，返回新数组。出队操作弹出数组第一个
    
    </summary>
    
      <category term="Designpattern" scheme="http://yoursite.com/categories/Designpattern/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
</feed>
